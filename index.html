<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G√©n√©rateur de Planning Excel</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5rem;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .tabs {
            display: flex;
            border-bottom: 3px solid #eee;
            margin-bottom: 20px;
            overflow-x: auto;
        }
        
        .tab {
            padding: 15px 25px;
            cursor: pointer;
            border: none;
            background: #f8f9fa;
            margin-right: 5px;
            border-radius: 10px 10px 0 0;
            font-weight: bold;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .tab:hover {
            background: #e9ecef;
            transform: translateY(-2px);
        }
        
        .tab.active {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.5s ease-in;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .planning-grid {
            display: grid;
            grid-template-columns: 80px repeat(7, 1fr);
            gap: 2px;
            background: #ddd;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        .planning-grid > div[style*="display: none"] {
    display: none !important;
}
        .time-slot {
            background: #f8f9fa;
            padding: 8px;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            border-right: 1px solid #ddd;
        }
        
        .planning-cell {
            background: white;
            padding: 5px;
            min-height: 25px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
        }
        
        .planning-cell:hover {
            transform: scale(1.02);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 10;
        }
        
        .planning-cell input {
            border: none;
            background: transparent;
            width: 100%;
            text-align: center;
            font-size: 11px;
            font-weight: bold;
            color: inherit;
        }
        
        .planning-cell input:focus {
            outline: 2px solid #667eea;
            border-radius: 3px;
        }
        
        .header-cell {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            font-weight: bold;
            text-align: center;
            padding: 12px;
            font-size: 14px;
        }
        
        /* Couleurs pour les postes */
        .bvs1 { background: #e91e63; color: white; }
        .bvs2 { background: #ff9800; color: white; }
        .portail { background: #ff5722; color: white; }
        .voltige { background: #2196f3; color: white; }
        .renfort { background: #795548; color: white; }
        .cours-impaire { background: #4caf50; color: white; }
        .cours-paire { background: #8bc34a; color: white; }
        .etude-impaire { background: #9c27b0; color: white; }
        .etude-paire { background: #673ab7; color: white; }
        .ap { background: #009688; color: white; }
        .hall { background: #607d8b; color: white; }
        .refectoire { background: #ff6f00; color: white; }
        .turbo { background: #f44336; color: white; }
        .bureau-midi { background: #3f51b5; color: white; }
        .pause { background: #9e9e9e; color: white; }
        .marsons { background: #00bcd4; color: white; }
        
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }
        
        .btn-success {
            background: linear-gradient(45deg, #4caf50, #45a049);
            color: white;
        }
        
        .btn-danger {
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
        }
        
        .activity-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .activity-btn {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 20px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            transition: all 0.2s ease;
            text-align: center;
        }
        
        .activity-btn:hover {
            transform: scale(1.05);
        }
        
        .activity-btn.selected {
            border-color: #667eea;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.3);
        }
        
        .legend {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .clear-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 12px;
        }
        .planning-table th, .planning-table td {
    border: 1px solid #ddd;
    padding: 4px;
    text-align: center;
}
        /* Tableau de synth√®se - bordures et responsive */
.synthese-responsive {
  width: 100%;
  overflow-x: auto;
  margin-bottom: 20px;
}

#synthese-table table {
  border-collapse: collapse;
  width: 100%;
  min-width: 400px;
}

#synthese-table th, #synthese-table td {
  border: 2px solid #764ba2;
  padding: 8px;
  text-align: center;
  background: #fff;
  font-size: 15px;
}

#synthese-table th {
  background: linear-gradient(45deg, #667eea, #764ba2);
  color: #fff;
}

@media (max-width: 700px) {
  #synthese-table th, #synthese-table td {
    padding: 4px;
    font-size: 11px;
  }
  #synthese-table table { min-width: 300px; }
}
    </style>
</head>
<body>
    <div class="container">
        <h1>üìÖ G√©n√©rateur de Planning Excel</h1>

        <div class="controls">
            <button class="btn btn-success" onclick="generateExcel()">üìä G√©n√©rer fichier Excel</button>
            <button class="btn btn-danger" onclick="clearAll()">üóëÔ∏è Effacer tout</button>
            
<!-- Bouton d'import -->
<input type="file" id="import-excel" accept=".xlsx,.xls" style="display:none" />
<button class="btn btn-primary" onclick="document.getElementById('import-excel').click()">Importer un fichier Excel</button>
        <div class="controls">
    <h3>Configuration des noms pour le PDF</h3>
    <div id="name-mapping" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 15px;">
        <!-- Les inputs seront g√©n√©r√©s dynamiquement -->
    </div>
    <button class="btn btn-primary" onclick="resetNames()">R√©initialiser les noms</button>
</div>
            <button class="btn btn-primary" onclick="generatePDF()">üñ®Ô∏è G√©n√©rer PDF imprimable</button>
        </div>
        
        <div class="activity-selector">
            <div class="activity-btn bvs1" onclick="selectActivity('BVS1')">B1</div>
            <div class="activity-btn bvs2" onclick="selectActivity('BVS2')">B2</div>
            <div class="activity-btn portail" onclick="selectActivity('Portail')">Portail</div>
            <div class="activity-btn voltige" onclick="selectActivity('Voltige')">Suivi de classe/accompagnement √©l√®ves/aide bureau</div>
            <div class="activity-btn renfort" onclick="selectActivity('Renfort surveillance')">Cours/WC/Hall</div>
            <div class="activity-btn cours-impaire" onclick="selectActivity('Cours Impaire')">Cours Impaire</div>
            <div class="activity-btn cours-paire" onclick="selectActivity('Cours paire')">Cours paire</div>
            <div class="activity-btn etude-impaire" onclick="selectActivity('Etude impaire')">Etude 1</div>
            <div class="activity-btn etude-paire" onclick="selectActivity('Etude paire')">Etude 2</div>
            <div class="activity-btn ap" onclick="selectActivity('AP')">Assistanat p√©dagogique</div>
            <div class="activity-btn hall" onclick="selectActivity('Hall')">Hall</div>
            <div class="activity-btn refectoire" onclick="selectActivity('R√©fectoire')">R√©fectoire</div>
            <div class="activity-btn turbo" onclick="selectActivity('Turbo')">Turbo</div>
            <div class="activity-btn bureau-midi" onclick="selectActivity('Bureau midi')">Bureau midi</div>
            <div class="activity-btn pause" onclick="selectActivity('Pause')">Pause</div>
            <div class="activity-btn marsons" onclick="selectActivity('Marsons')">Marsons</div>
        </div>

        <div class="clear-buttons">
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('BVS1')">‚ùå Effacer B1</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('BVS2')">‚ùå Effacer B2</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Portail')">‚ùå Effacer Portail</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Voltige')">‚ùå Effacer Voltige</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Renfort surveillance')">‚ùå Effacer Renforts</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Cours Impaire')">‚ùå Effacer Cours Impaire</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Cours paire')">‚ùå Effacer Cours paire</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Etude impaire')">‚ùå Effacer Etude 1</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Etude paire')">‚ùå Effacer Etude 2</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('AP')">‚ùå Effacer AP</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Hall')">‚ùå Effacer Hall</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('R√©fectoire')">‚ùå Effacer R√©fectoire</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Turbo')">‚ùå Effacer Turbo</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Bureau midi')">‚ùå Effacer Bureau midi</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Pause')">‚ùå Effacer Pause</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Marsons')">‚ùå Effacer Marsons</button>
        </div>
        
        <div class="tabs">
            <div class="tab active" onclick="showTab('lundi')">Lundi</div>
            <div class="tab" onclick="showTab('mardi')">Mardi</div>
            <div class="tab" onclick="showTab('mercredi')">Mercredi</div>
            <div class="tab" onclick="showTab('jeudi')">Jeudi</div>
            <div class="tab" onclick="showTab('vendredi')">Vendredi</div>
            <div class="tab" onclick="showTab('synthese')">Synth√®se</div>
            <div class="tab" onclick="showTab('syntheseJour')">Synth√®se par jour</div>
        </div>
        
        <div id="lundi" class="tab-content active">
            <h3>Planning Lundi</h3>
            <div id="planning-lundi" class="planning-grid"></div>
        </div>
        
        <div id="mardi" class="tab-content">
            <h3>Planning Mardi</h3>
            <div id="planning-mardi" class="planning-grid"></div>
        </div>
        
        <div id="mercredi" class="tab-content">
            <h3>Planning Mercredi</h3>
            <div id="planning-mercredi" class="planning-grid"></div>
        </div>
        
        <div id="jeudi" class="tab-content">
            <h3>Planning Jeudi</h3>
            <div id="planning-jeudi" class="planning-grid"></div>
        </div>
        
        <div id="vendredi" class="tab-content">
            <h3>Planning Vendredi</h3>
            <div id="planning-vendredi" class="planning-grid"></div>
        </div>
        <div id="synthese" class="tab-content">
  <h3>Synth√®se du temps par poste et personne</h3>
  <div class="synthese-responsive"><div id="synthese-table"></div></div>
</div>
        <div id="syntheseJour" class="tab-content">
  <h3>Synth√®se Journalier par personne</h3>
  <div class="synthese-responsive"><div id="syntheseJour-table"></div></div>
</div>
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color bvs1"></div>
                <span>BVS1</span>
            </div>
            <div class="legend-item">
                <div class="legend-color bvs2"></div>
                <span>BVS2</span>
            </div>
            <div class="legend-item">
                <div class="legend-color portail"></div>
                <span>Portail</span>
            </div>
            <div class="legend-item">
                <div class="legend-color voltige"></div>
                <span>Suivi de classe/accompagnement √©l√®ves/aide bureau</span>
            </div>
            <div class="legend-item">
                <div class="legend-color renfort"></div>
                <span>Cours/WC/Hall</span>
            </div>
            <div class="legend-item">
                <div class="legend-color cours-impaire"></div>
                <span>Cours Impaire</span>
            </div>
            <div class="legend-item">
                <div class="legend-color cours-paire"></div>
                <span>Cours paire</span>
            </div>
            <div class="legend-item">
                <div class="legend-color etude-impaire"></div>
                <span>Etude impaire</span>
            </div>
            <div class="legend-item">
                <div class="legend-color etude-paire"></div>
                <span>Etude paire</span>
            </div>
            <div class="legend-item">
                <div class="legend-color ap"></div>
                <span>Assitanat p√©dagogique</span>
            </div>
            <div class="legend-item">
                <div class="legend-color hall"></div>
                <span>Hall</span>
            </div>
            <div class="legend-item">
                <div class="legend-color refectoire"></div>
                <span>R√©fectoire</span>
            </div>
            <div class="legend-item">
                <div class="legend-color turbo"></div>
                <span>Turbo</span>
            </div>
            <div class="legend-item">
                <div class="legend-color bureau-midi"></div>
                <span>Bureau midi</span>
            </div>
            <div class="legend-item">
                <div class="legend-color pause"></div>
                <span>Pause</span>
            </div>
            <div class="legend-item">
                <div class="legend-color marsons"></div>
                <span>Marsons</span>
            </div>
        </div>
    </div>

    <script>
        const timeSlots = [
            '07:25', '07:30','07:35', '07:40', '07:45', '07:50', '07:55', '08:00', '08:05', '08:10', '08:15',
            '08:20', '08:25', '08:30', '08:35', '08:40', '08:45', '08:50', '08:55', '09:00', '09:05',
            '09:10', '09:15', '09:20', '09:25', '09:30', '09:35', '09:40', '09:45', '09:50', '09:55',
            '10:00', '10:05', '10:10', '10:15', '10:20', '10:25', '10:30', '10:35', '10:40', '10:45',
            '10:50', '10:55', '11:00', '11:05', '11:10', '11:15', '11:20', '11:25', '11:30', '11:35',
            '11:40', '11:45', '11:50', '11:55', '12:00', '12:05', '12:10', '12:15', '12:20', '12:25',
            '12:30', '12:35', '12:40', '12:45', '12:50', '12:55', '13:00', '13:05', '13:10', '13:15',
            '13:20', '13:25', '13:30', '13:35', '13:40', '13:45', '13:50', '13:55', '14:00', '14:05',
            '14:10', '14:15', '14:20', '14:25', '14:30', '14:35', '14:40', '14:45', '14:50', '14:55',
            '15:00', '15:05', '15:10', '15:15', '15:20', '15:25', '15:30', '15:35', '15:40', '15:45',
            '15:50', '15:55', '16:00', '16:05', '16:10', '16:15', '16:20', '16:25', '16:30', '16:35',
            '16:40', '16:45', '16:50', '16:55', '17:00', '17:05', '17:10', '17:15', '17:20', '17:25',
            '17:30', '17:35'
        ];
        
        const columns = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
        const days = ['lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi'];
        
        let selectedActivity = 'BVS1';
        let isMouseDown = false;
        let dragActivity = null;
        let startDay = null;
        let startCol = null;
        let startRow = null;
        let planningData = {};
        // Table de correspondance pour l'affichage (affichage => interne)
const affichageMapping = {
  'Voltige': 'Suivi de classe/accompagnement √©l√®ves/aide bureau',
  'Renfort surveillance': 'Cours/WC/Hall'
};
// Table inverse (interne => affichage)
const affichageReverseMapping = {
  'Suivi de classe/accompagnement √©l√®ves/aide bureau': 'Voltige',
  'Cours/WC/Hall': 'Renfort surveillance'
};
        // Stockage des noms personnalis√©s
let customNames = {};

// Initialiser les noms par d√©faut
function initializeNames() {
    columns.forEach(col => {
        if (!customNames[col]) {
            customNames[col] = col; // Par d√©faut, utiliser la lettre de la colonne
        }
    });
    updateNameInputs();
}

// Mettre √† jour les inputs de noms
function updateNameInputs() {
    const container = document.getElementById('name-mapping');
    container.innerHTML = '';
    
    columns.forEach(col => {
        const div = document.createElement('div');
        div.innerHTML = `
            <label for="name-${col}" style="display: block; font-weight: bold; margin-bottom: 5px;">
                Colonne ${col}:
            </label>
            <input type="text" 
                   id="name-${col}" 
                   value="${customNames[col] || col}" 
                   placeholder="Nom de la personne"
                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;"
                   onchange="updateCustomName('${col}', this.value)">
        `;
        container.appendChild(div);
    });
}

// Mettre √† jour un nom personnalis√©
function updateCustomName(col, name) {
    customNames[col] = name.trim() || col;
}

// R√©initialiser les noms aux valeurs par d√©faut
function resetNames() {
    columns.forEach(col => {
        customNames[col] = col;
    });
    updateNameInputs();
}

// Obtenir le nom d'affichage pour une colonne
function getDisplayName(col) {
    return customNames[col] || col;
}
function getAffichage(nom) {
  return affichageMapping[nom] || nom;
}
function getNomInterne(nom) {
  // pour l'enregistrement/import/export
  return affichageReverseMapping[nom] || nom;
}
        // Initialiser les donn√©es de planning
        days.forEach(day => {
            planningData[day] = {};
            timeSlots.forEach(time => {
                planningData[day][time] = {};
                columns.forEach(col => {
                    planningData[day][time][col] = '';
                });
            });
        });
        document.addEventListener('mouseup', () => isMouseDown = false);

document.querySelectorAll('.planning-cell').forEach(cell => {
  cell.addEventListener('mousedown', function() {
    isMouseDown = true;
    // Remplir la cellule
  });
  cell.addEventListener('mouseover', function() {
    if (isMouseDown) {
      // Remplir la cellule
    }
  });
});
        function initializePlannings() {
            days.forEach(day => {
                createPlanningGrid(day);
            });
        }
        function createPlanningGrid(day) {
            const container = document.getElementById(`planning-${day}`);
            container.innerHTML = '';
            
            // Headers
            container.appendChild(createCell('', 'header-cell'));
            columns.forEach(col => {
                container.appendChild(createCell(col, 'header-cell'));
            });
            
            // Time slots and data
            timeSlots.forEach(time => {
                container.appendChild(createCell(time, 'time-slot'));
                columns.forEach(col => {
                    const cell = createPlanningCell(day, time, col);
                    container.appendChild(cell);
                });
            });
            
            // Appelle la fusion des cellules identiques seulement apr√®s avoir tout cr√©√©
            mergeIdenticalCells(day);
        }

        
        function createCell(content, className) {
            const cell = document.createElement('div');
            cell.className = className;
            cell.textContent = content;
            return cell;
        }
        
function createPlanningCell(day, time, col) {
    const cell = document.createElement('div');
    cell.className = 'planning-cell';

    // Rep√®re la position de la cellule
    const rowIdx = timeSlots.indexOf(time);
    const colIdx = columns.indexOf(col);

    // Gestion drag & drop
    cell.onmousedown = function(e) {
        isMouseDown = true;
        dragActivity = selectedActivity;
        startDay = day;
        startCol = col;
        startRow = rowIdx;
        updateCell(day, time, col, dragActivity, false);
        document.body.style.userSelect = "none";
    };
    cell.onmouseover = function(e) {
        if (isMouseDown && dragActivity && day === startDay && col === startCol) {
            // Remplit les cases entre startRow et rowIdx
            let min = Math.min(startRow, rowIdx);
            let max = Math.max(startRow, rowIdx);
            for (let r = min; r <= max; r++) {
                let t = timeSlots[r];
                planningData[day][t][col] = dragActivity;
            }
            createPlanningGrid(day);
        }
    };
    cell.onmouseup = function(e) {
        isMouseDown = false;
        dragActivity = null;
        startDay = null;
        startCol = null;
        startRow = null;
        document.body.style.userSelect = "";
    };

    // Pour mobile/tactile‚ÄØ:
    cell.ontouchstart = function(e) {
        isMouseDown = true;
        dragActivity = selectedActivity;
        startDay = day;
        startCol = col;
        startRow = rowIdx;
        updateCell(day, time, col, dragActivity, false);
    };
    cell.ontouchmove = function(e) {
        if (!isMouseDown) return;
        const touch = e.touches[0];
        const target = document.elementFromPoint(touch.clientX, touch.clientY);
        if (target && target.classList.contains('planning-cell')) {
            const idx = Array.from(target.parentNode.children).indexOf(target);
            // (Optionnel: tu peux retrouver la position exacte ici)
        }
    };
    cell.ontouchend = function(e) {
        isMouseDown = false;
        dragActivity = null;
        startDay = null;
        startCol = null;
        startRow = null;
    };

    // On continue d'afficher l'input pour l'√©dition manuelle
    const input = document.createElement('input');
    input.type = 'text';
    input.value = getAffichage(planningData[day][time][col]);
    input.onchange = function() {
        planningData[day][time][col] = getNomInterne(this.value);
        updateCellAppearance(cell, this.value);
    };

    cell.appendChild(input);
    updateCellAppearance(cell, planningData[day][time][col]);
    return cell;
}
        
        function updateCell(day, time, col, activity) {
            planningData[day][time][col] = activity;
            createPlanningGrid(day);
        }
        
        function updateCellAppearance(cell, value) {
            // Retirer toutes les classes d'activit√©
            const activityClasses = ['bvs1', 'bvs2', 'portail', 'voltige', 'renfort', 'cours-impaire', 'cours-paire', 'etude-impaire', 'etude-paire', 'ap', 'hall', 'refectoire', 'turbo', 'bureau-midi', 'pause', 'marsons'];
            activityClasses.forEach(cls => cell.classList.remove(cls));
            
            if (value) {
                const activity = value.toLowerCase()
                    .replace(/\s+/g, '-')
                    .replace('renfort-surveillance', 'renfort')
                    .replace('r√©fectoire', 'refectoire');
                if (activityClasses.includes(activity)) {
                    cell.classList.add(activity);
                }
            }
        }
        
        function clearSpecificPoste(poste) {
            if (confirm(`√ätes-vous s√ªr de vouloir effacer tous les "${poste}" ?`)) {
                days.forEach(day => {
                    timeSlots.forEach(time => {
                        columns.forEach(col => {
                            if (planningData[day][time][col] === poste) {
                                planningData[day][time][col] = '';
                            }
                        });
                    });
                    createPlanningGrid(day);
                });
            }
        }
        
        function selectActivity(activity) {
            selectedActivity = activity;
            document.querySelectorAll('.activity-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            event.target.classList.add('selected');
        }
        
       function showTab(day) {
    document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
    event.target.classList.add('active');
    document.getElementById(day).classList.add('active');
    if(day === 'synthese') {
        generateSynthesePersonneVolume();
    }
            if(day === 'syntheseJour') {
        generateSynthesePersonneParJour();
    }
}
        
        function clearAll() {
            if (confirm('√ätes-vous s√ªr de vouloir effacer tous les plannings ?')) {
                days.forEach(day => {
                    timeSlots.forEach(time => {
                        columns.forEach(col => {
                            planningData[day][time][col] = '';
                        });
                    });
                    createPlanningGrid(day);
                });
            }
        }
        function mergeIdenticalCells(day) {
    const rows = timeSlots.length;
    const cols = columns.length;
    const grid = document.getElementById('planning-' + day);
    if (!grid) return;

    // Construction du tableau des cellules (donn√©es uniquement)
    const cellsMatrix = [];
    for (let col = 0; col < cols; col++) {
        cellsMatrix[col] = [];
        for (let row = 0; row < rows; row++) {
            // Sauter la toute premi√®re ligne (ent√™te)
            const idx = (row + 1) * (cols + 1) + (col + 1);
            cellsMatrix[col][row] = grid.children[idx];
        }
    }

    // Fusionne uniquement les cellules de donn√©es (pas l'ent√™te)
    for (let col = 0; col < cols; col++) {
        let start = 0;
        while (start < rows) {
            let end = start;
            while (
                end + 1 < rows &&
                planningData[day][timeSlots[end]][columns[col]] &&
                planningData[day][timeSlots[end]][columns[col]] === planningData[day][timeSlots[end + 1]][columns[col]]
            ) {
                end++;
            }
            if (end > start) {
                cellsMatrix[col][start].style.gridRow = `span ${end - start + 1}`;
                for (let r = start + 1; r <= end; r++) {
                    cellsMatrix[col][r].style.display = "none";
                }
            } else {
                cellsMatrix[col][start].style.gridRow = "";
                cellsMatrix[col][start].style.display = "";
            }
            start = end + 1;
        }
    }
}
       function generateExcel() {
     const wb = XLSX.utils.book_new();

    // Couleurs identiques √† ton code
    const activityColors = {
        'bvs1': 'FFC91E63',
        'bvs2': 'FFFF9800',
        'portail': 'FFFF5722',
        'voltige': 'FF2196F3',
        'renfort': 'FF795548',
        'cours-impaire': 'FF4CAF50',
        'cours-paire': 'FF8BC34A',
        'etude-impaire': 'FF9C27B0',
        'etude-paire': 'FF673AB7',
        'ap': 'FF009688',
        'hall': 'FF607D8B',
        'refectoire': 'FFFF6F00',
        'turbo': 'FFF44336',
        'bureau-midi': 'FF3F51B5',
        'pause': 'FF9E9E9E',
        'marsons': 'FF00BCD4'
    };
    function getActivityKey(value) {
        if (!value) return null;
        let key = value.toLowerCase()
            .replace(/\s+/g, '-')
            .replace('renfort-surveillance', 'renfort')
            .replace('r√©fectoire', 'refectoire');
        return activityColors[key] ? key : null;
    }

    days.forEach(day => {
        const wsData = [];
        const headerRow = ['Heure', ...columns];
        wsData.push(headerRow);

        // G√©n√©ration des donn√©es ligne par ligne
        timeSlots.forEach(time => {
            const row = [time];
            columns.forEach(col => {
                row.push(planningData[day][time][col] || '');
            });
            wsData.push(row);
        });

        const ws = XLSX.utils.aoa_to_sheet(wsData);

        // Ajout des couleurs
        for(let r=1; r<wsData.length; r++) { // r=1 pour ignorer l'ent√™te
            for(let c=1; c<=columns.length; c++) { // c=1 car colonne 0 = heure
                const value = wsData[r][c];
                const colorKey = getActivityKey(value);
                if (colorKey) {
                    const cellAddress = XLSX.utils.encode_cell({r, c});
                    if (!ws[cellAddress]) ws[cellAddress] = { t: 's', v: value };
                    ws[cellAddress].s = {
                        fill: { fgColor: { rgb: activityColors[colorKey] } },
                        font: { color: { rgb: "FFFFFFFF" }, bold: true }
                    };
                }
            }
        }

        // Fusion des cellules (d√©j√† vu pr√©c√©demment)
        ws['!merges'] = [];
        columns.forEach((col, colIdx) => {
            let start = 1;
            let value = wsData[start][colIdx + 1];
            for (let row = 2; row < wsData.length; row++) {
                if (wsData[row][colIdx + 1] !== value) {
                    if (row - start > 1 && value) {
                        ws['!merges'].push({ s: { r: start, c: colIdx + 1 }, e: { r: row - 1, c: colIdx + 1 } });
                    }
                    start = row;
                    value = wsData[row][colIdx + 1];
                }
            }
            if (wsData.length - start > 1 && value) {
                ws['!merges'].push({ s: { r: start, c: colIdx + 1 }, e: { r: wsData.length - 1, c: colIdx + 1 } });
            }
        });

        // Largeur des colonnes
        ws['!cols'] = [{ wch: 10 }];
        columns.forEach(() => ws['!cols'].push({ wch: 15 }));

        XLSX.utils.book_append_sheet(wb, ws, day.charAt(0).toUpperCase() + day.slice(1));
    });

    // Sauvegarder en .xlsx pour garder la mise en forme
    XLSX.writeFile(wb, 'planning_hebdomadaire.xlsx');
}


        function updateCell(day, time, col, activity, refresh = true) {
    planningData[day][time][col] = activity;
    if (refresh) createPlanningGrid(day);
}

        document.getElementById('import-excel').addEventListener('change', handleExcelImportAllDays);


        function handleExcelImportAllDays(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: 'array' });
        const dayNames = ['lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi'];

        let changedDay = false;
        dayNames.forEach(day => {
            // Cherche la feuille correspondante (insensible √† la casse)
            const sheetName = workbook.SheetNames.find(n => n.trim().toLowerCase() === day);
            if (!sheetName) return;
            const sheet = workbook.Sheets[sheetName];

            // On r√©cup√®re les fusions √©ventuelles
            const merges = sheet['!merges'] || [];

            // On parse les donn√©es "classiquement"
            const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
            // On va d'abord remplir normalement
            for (let i = 1; i < rows.length; i++) { // Commence √† 1 (skip header)
                const row = rows[i];
                const time = row[0];
                if (!planningData[day][time]) continue; // Ignore heures non trouv√©es
                for (let c = 0; c < columns.length; c++) {
                    planningData[day][time][columns[c]] = row[c + 1] || '';
                }
            }

            // Maintenant, on traite les merges
            merges.forEach(merge => {
                // merge.s: { r: startRow, c: startCol }
                // merge.e: { r: endRow, c: endCol }
                // Header = ligne 0, colonne 0
                const startRow = merge.s.r, endRow = merge.e.r;
                const startCol = merge.s.c, endCol = merge.e.c;
                // La valeur fusionn√©e est dans la cellule de d√©part
                const value = rows[startRow]?.[startCol] ?? '';
                // Appliquer cette valeur √† toutes les cases de la plage fusionn√©e
                for (let r = startRow; r <= endRow; r++) {
                    // Rappel‚ÄØ: colonne 0 = heure, donc colonne 1 = colonne "A"
                    const time = rows[r]?.[0];
                    if (!planningData[day][time]) continue;
                    for (let c = startCol; c <= endCol; c++) {
                        if (c === 0) continue; // ne jamais √©crire sur la colonne des heures
                        planningData[day][time][columns[c - 1]] = value;
                    }
                }
            });

            changedDay = true;
            createPlanningGrid(day);
        });

        if (changedDay) {
            alert("Importation termin√©e !");
        } else {
            alert("Aucune feuille nomm√©e 'lundi', 'mardi', etc. trouv√©e dans le fichier.");
        }
    };
    reader.readAsArrayBuffer(file);
}
function generateSynthesePersonneVolume() {
    // Dur√©e d'un cr√©neau en minutes (√† ADAPTER selon ton planning)
    const slotDuration = 5; // change √† 15 si besoin
    // Cr√©ation du mapping personne -> item -> nbre de cr√©neaux
    const personMap = {};
    const itemMap = {};

    days.forEach(day => {
        timeSlots.forEach(time => {
            columns.forEach(col => {
                const value = planningData[day][time][col];
                if (value && value.trim() !== "") {
                    if (!personMap[col]) personMap[col] = {};
                    if (!personMap[col][value]) personMap[col][value] = 0;
                    personMap[col][value] += 1;
                   // Mise √† jour de itemMap
                if (!itemMap[value]) itemMap[value] = [];
                // On cherche si la personne existe d√©j√† pour ce value dans itemMap
                let personEntry = itemMap[value].find(entry => entry.col === col);
                if (personEntry) {
                    personEntry.nbre += 1;
                } else {
                    itemMap[value].push({ col, nbre: 1 });
                }
            }
        });
    });
});

    // Liste des personnes tri√©es
    const allPeople = Object.keys(personMap).sort();
    // Liste des items (postes)
    const allItems = Object.keys(itemMap).sort();;

    // Construction du tableau HTML
    let html = `<table class="table table-bordered"><thead><tr><th>Personne</th>`;
    allItems.forEach(item => html += `<th>${item}</th>`);
    html += `<th>Total</th></tr></thead><tbody>`;

    allPeople.forEach(person => {
        let totalMinutes = 0;
        html += `<tr><td>${person}</td>`;
        allItems.forEach(item => {
            const count = personMap[person][item] || 0;
            const minutes = count * slotDuration;
            totalMinutes += minutes;
            
             const idCell = `id="${person.replace(/\s/g,'_')}+${item.replace(/\s/g,'_')}"`;
        html += `<td ${idCell}>${minutes > 0 ? formatHM(minutes) : ""}</td>`;
        });
        html += `<td><b>${totalMinutes > 0 ? formatHM(totalMinutes) : ""}</b></td></tr>`;
    });

    html += `</tbody></table>`;
    document.getElementById("synthese-table").innerHTML = html;
    colorerSyntheseParItem(); // <-- Ajout ici
}

// Format X min => HhMMmin
function formatHM(mins) {
    if (mins <= 0) return "";
    const h = Math.floor(mins / 60);
    const m = mins % 60;
    return h > 0 ? `${h}h${m > 0 ? m : ""}` : `${m}min`;
}

// Helper : minutes ‚Üí format "XhYY" ou "ZZ min"
function formatDuree(minutes) {
    if (minutes >= 60) {
        const h = Math.floor(minutes / 60);
        const m = minutes % 60;
        return h + 'h' + (m ? (m < 10 ? '0' : '') + m : '');
    }
    return minutes + ' min';
}
function generateSynthesePersonneParJour() {
    const slotDuration = 5; // ou 15 si tu utilises 15 minutes
    const personDayMap = {}; // { personne: { lundi: n, mardi: n, ... } }

    days.forEach(day => {
        timeSlots.forEach(time => {
            columns.forEach(col => {
                const value = planningData[day][time][col];
                if (value && value.trim() !== "") {
                    if (!personDayMap[col]) personDayMap[col] = {};
                    if (!personDayMap[col][day]) personDayMap[col][day] = 0;
                    personDayMap[col][day] += 1;
                }
            });
        });
    });

    // Liste personnes tri√©es
    const allPeople = Object.keys(personDayMap).sort();

    // Construction du tableau HTML
    let html = `<table class="table table-bordered"><thead><tr><th>Personne</th>`;
    days.forEach(day => html += `<th>${day.charAt(0).toUpperCase() + day.slice(1)}</th>`);
    html += `<th>Total</th></tr></thead><tbody>`;

    allPeople.forEach(person => {
        let total = 0;
        html += `<tr><td>${person}</td>`;
        days.forEach(day => {
            const count = (personDayMap[person][day] || 0);
            const minutes = count * slotDuration;
            total += minutes;
            html += `<td>${minutes > 0 ? formatHM(minutes) : ""}</td>`;
        });
        html += `<td><b>${total > 0 ? formatHM(total) : ""}</b></td></tr>`;
    });

    html += `</tbody></table>`;
    document.getElementById("syntheseJour-table").innerHTML = html;
}
function colorerSyntheseParItem() {
    const table = document.querySelector('#synthese-table table');
    if (!table) return;
    const rows = Array.from(table.querySelectorAll('tbody tr'));
    if (rows.length === 0) return;

    // R√©cup√®re les items (postes) depuis l'en-t√™te
    const ths = Array.from(table.querySelectorAll('thead th'));
    const items = ths.slice(1, -1).map(th => th.textContent.trim()); // Ignore "Personne" et "Total"

    // Trouve les index des colonnes √† exclure (F et G)
    const excludeColsLabels = ['F', 'G'];
    const excludeIndexes = [];
    items.forEach((item, idx) => {
        if (excludeColsLabels.includes(item)) excludeIndexes.push(idx);
    });

    // Calcule la moyenne pour chaque poste (sauf F et G)
    let moyennes = [];
    items.forEach((item, colIdx) => {
        if (excludeIndexes.includes(colIdx)) {
            moyennes[colIdx] = null; // On ne calcule pas la moyenne pour F et G
            return;
        }
        let total = 0, count = 0;
        rows.forEach(row => {
            const cell = row.querySelectorAll('td')[colIdx + 1];
            if (!cell) return;
            let minutes = 0;
            let m = cell.textContent.match(/(\d+)h(\d+)?/);
            if (m) {
                minutes = parseInt(m[1]) * 60 + (m[2] ? parseInt(m[2]) : 0);
            } else {
                let m2 = cell.textContent.match(/(\d+)min/);
                if (m2) minutes = parseInt(m2[1]);
            }
            if (minutes > 0) {
                total += minutes;
                count++;
            }
        });
        moyennes[colIdx] = count ? total / count : 0;
    });

    // Applique les couleurs si l'√©cart d√©passe ¬±60 min (sauf F et G)
    rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        items.forEach((item, colIdx) => {
            if (excludeIndexes.includes(colIdx)) {
                // Pas de couleur sur F et G, mais on nettoie le style
                const cell = cells[colIdx + 1];
                if (cell) {
                    cell.style.backgroundColor = '';
                    cell.style.fontWeight = '';
                }
                return;
            }
            const cell = cells[colIdx + 1];
            if (!cell) return;
            let minutes = 0;
            let m = cell.textContent.match(/(\d+)h(\d+)?/);
            if (m) {
                minutes = parseInt(m[1]) * 60 + (m[2] ? parseInt(m[2]) : 0);
            } else {
                let m2 = cell.textContent.match(/(\d+)min/);
                if (m2) minutes = parseInt(m2[1]);
            }
            let moyenne = moyennes[colIdx] || 0;
            let color = '';
            let ecart = minutes - moyenne;
            if (minutes > 0 && Math.abs(ecart) > 60) {
                if (ecart > 60) {
                    // Violet, intensit√© selon l'√©cart positif
                    let intensite = Math.min((ecart - 60) / (moyenne || 1), 1);
                    color = `rgba(138, 43, 226, ${0.3 + 0.7 * intensite})`;
                } else if (ecart < -60) {
                    // Orange, intensit√© selon l'√©cart n√©gatif
                    let intensite = Math.min((-ecart - 60) / (moyenne || 1), 1);
                    color = `rgba(255, 140, 0, ${0.3 + 0.7 * intensite})`;
                }
                cell.style.backgroundColor = color;
                cell.style.fontWeight = "bold";
            } else {
                cell.style.backgroundColor = '';
                cell.style.fontWeight = '';
            }
        });
    });
}
function generatePDF() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('l', 'pt', 'a4');
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();

    let isFirstPage = true;

    days.forEach((day, dayIndex) => {
        if (!isFirstPage) {
            doc.addPage();
        }
        isFirstPage = false;

        // Titre du jour
        doc.setFontSize(16);
        doc.setFont('helvetica', 'bold');
        doc.text(day.charAt(0).toUpperCase() + day.slice(1), pageWidth / 2, 30, { align: "center" });

        const relevantSlots = timeSlots.filter(time => {
            return columns.some(col => {
                const value = planningData[day][time][col];
                return value && value.trim() !== '';
            });
        });

        if (relevantSlots.length === 0) {
            doc.setFontSize(12);
            doc.setFont('helvetica', 'normal');
            doc.text("Aucune donn√©e pour ce jour", pageWidth / 2, pageHeight / 2, { align: "center" });
            return;
        }

        const mergeInfo = analyzeMerges(day, relevantSlots);
        const startY = 50;
        const availableHeight = pageHeight - startY - 20;
        const availableWidth = pageWidth - 40;
        const totalRows = relevantSlots.length + 1;
        const minRowHeight = 12;
        const rowHeight = Math.max(minRowHeight, Math.floor(availableHeight / totalRows));
        const fontSize = Math.max(6, Math.min(10, rowHeight - 2));
        const timeColWidth = 60;
        const dataColWidth = (availableWidth - timeColWidth) / columns.length;
        const totalTableHeight = totalRows * rowHeight;

        if (totalTableHeight > availableHeight) {
            drawPlanningTableWithPaginationCustomNames(doc, day, relevantSlots, mergeInfo, startY, timeColWidth, dataColWidth, minRowHeight, fontSize, availableHeight, pageWidth, pageHeight);
        } else {
            drawPlanningTableWithMergesCustomNames(doc, day, relevantSlots, mergeInfo, startY, timeColWidth, dataColWidth, rowHeight, fontSize);
        }
    });

    doc.save('planning_hebdomadaire.pdf');
}

function drawPlanningTableWithMergesCustomNames(doc, day, relevantSlots, mergeInfo, startY, timeColWidth, dataColWidth, rowHeight, fontSize) {
    let currentY = startY;
    
    // Dessiner l'en-t√™te
    doc.setFillColor(102, 126, 234);
    doc.rect(20, currentY, timeColWidth, rowHeight, 'F');

    columns.forEach((col, index) => {
        const x = 20 + timeColWidth + (index * dataColWidth);
        doc.rect(x, currentY, dataColWidth, rowHeight, 'F');
    });

    // Texte de l'en-t√™te avec noms personnalis√©s
    doc.setTextColor(255, 255, 255);
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(fontSize + 1);

    doc.text('Heure', 20 + timeColWidth/2, currentY + rowHeight/2 + 2, { align: 'center' });

    columns.forEach((col, index) => {
        const x = 20 + timeColWidth + (index * dataColWidth);
        const displayName = getDisplayName(col);
        const truncatedName = truncateText(doc, displayName, dataColWidth - 4, fontSize + 1);
        doc.text(truncatedName, x + dataColWidth/2, currentY + rowHeight/2 + 2, { align: 'center' });
    });

    currentY += rowHeight;

    // Le reste de la fonction reste identique √† l'original
    // (copiez le reste du code de drawPlanningTableWithMerges ici)
    
    // Dessiner d'abord tous les arri√®re-plans des cellules fusionn√©es
    relevantSlots.forEach((time, rowIndex) => {
        columns.forEach((col, colIndex) => {
            const merge = mergeInfo[col][rowIndex];
            const x = 20 + timeColWidth + (colIndex * dataColWidth);
            const y = startY + rowHeight + (rowIndex * rowHeight);

            if (merge && merge.value && merge.isFirst) {
                const color = getActivityColorRGB(merge.value);
                if (color) {
                    const mergeHeight = rowHeight * merge.mergeLength;
                    doc.setFillColor(color.r, color.g, color.b);
                    doc.rect(x, y, dataColWidth, mergeHeight, 'F');
                }
            }
        });
    });

    // Dessiner les lignes de donn√©es
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(fontSize);

    relevantSlots.forEach((time, rowIndex) => {
        const y = startY + rowHeight + (rowIndex * rowHeight);

        if (rowIndex % 2 === 0) {
            doc.setFillColor(248, 249, 250);
            doc.rect(20, y, timeColWidth, rowHeight, 'F');
        }

        doc.setTextColor(0, 0, 0);
        doc.setFont('helvetica', 'bold');
        doc.text(time, 20 + timeColWidth/2, y + rowHeight/2 + 2, { align: 'center' });

        doc.setFont('helvetica', 'bold');
        columns.forEach((col, colIndex) => {
            const merge = mergeInfo[col][rowIndex];
            const x = 20 + timeColWidth + (colIndex * dataColWidth);

            if (merge && merge.value) {
                const color = getActivityColorRGB(merge.value);
                if (color) {
                    doc.setTextColor(255, 255, 255);
                } else {
                    doc.setTextColor(0, 0, 0);
                }

                if (merge.isFirst) {
                    const maxWidth = dataColWidth - 4;
                    const truncatedText = truncateText(doc, merge.value, maxWidth, fontSize);
                    const textY = y + (rowHeight * merge.mergeLength) / 2 + 2;
                    doc.text(truncatedText, x + dataColWidth/2, textY, { align: 'center' });
                }
            }
        });
    });

    // Dessiner les bordures du tableau
    doc.setDrawColor(0, 0, 0);
    doc.setLineWidth(0.5);

    const tableWidth = timeColWidth + (columns.length * dataColWidth);
    const tableHeight = (relevantSlots.length + 1) * rowHeight;
    doc.rect(20, startY, tableWidth, tableHeight);

    doc.line(20 + timeColWidth, startY, 20 + timeColWidth, startY + tableHeight);
    for (let i = 1; i < columns.length; i++) {
        const x = 20 + timeColWidth + (i * dataColWidth);
        doc.line(x, startY, x, startY + tableHeight);
    }

    for (let i = 1; i <= relevantSlots.length; i++) {
        const y = startY + (i * rowHeight);
        if (i === 1) {
            doc.line(20, y, 20 + tableWidth, y);
        } else {
            doc.line(20, y, 20 + timeColWidth, y);
            columns.forEach((col, colIndex) => {
                const rowIndex = i - 2;
                if (rowIndex >= 0 && rowIndex < relevantSlots.length) {
                    const merge = mergeInfo[col][rowIndex];
                    const x = 20 + timeColWidth + (colIndex * dataColWidth);
                    if (!merge || !merge.isMerged || merge.isLast) {
                        doc.line(x, y, x + dataColWidth, y);
                    }
                } else if (i === relevantSlots.length + 1) {
                    const x = 20 + timeColWidth + (colIndex * dataColWidth);
                    doc.line(x, y, x + dataColWidth, y);
                }
            });
        }
    }
}

function drawPlanningTableWithPaginationCustomNames(doc, day, relevantSlots, mergeInfo, startY, timeColWidth, dataColWidth, minRowHeight, fontSize, availableHeight, pageWidth, pageHeight) {
    // Cette fonction utilise la m√™me logique que drawOptimizedPlanningWithPagination
    // mais appelle drawPlanningTableWithMergesCustomNames au lieu de drawPlanningTableWithMerges
    
    const headerHeight = minRowHeight;
    const totalSlots = relevantSlots.length;
    const midPoint = Math.ceil(totalSlots / 2);
    
    const firstPageSlots = relevantSlots.slice(0, midPoint);
    const firstPageMergeInfo = createPageMergeInfo(day, firstPageSlots, mergeInfo, 0);
    const firstPageRowHeight = Math.max(12, Math.floor(availableHeight / (firstPageSlots.length + 1)));
    const firstPageFontSize = Math.max(6, Math.min(10, firstPageRowHeight - 2));
    
    drawPlanningTableWithMergesCustomNames(doc, day, firstPageSlots, firstPageMergeInfo, startY, timeColWidth, dataColWidth, firstPageRowHeight, firstPageFontSize);
    
    if (totalSlots > midPoint) {
        doc.addPage();
        doc.setFontSize(16);
        doc.setFont('helvetica', 'bold');
        doc.text(`${day.charAt(0).toUpperCase() + day.slice(1)} (2/2)`, pageWidth / 2, 30, { align: "center" });
        
        const secondPageSlots = relevantSlots.slice(midPoint);
        const secondPageMergeInfo = createPageMergeInfo(day, secondPageSlots, mergeInfo, midPoint);
        const secondPageRowHeight = Math.max(12, Math.floor(availableHeight / (secondPageSlots.length + 1)));
        const secondPageFontSize = Math.max(6, Math.min(10, secondPageRowHeight - 2));
        
        drawPlanningTableWithMergesCustomNames(doc, day, secondPageSlots, secondPageMergeInfo, startY, timeColWidth, dataColWidth, secondPageRowHeight, secondPageFontSize);
    }
}
        

function drawOptimizedPlanningWithPagination (doc, day, relevantSlots, mergeInfo, startY, timeColWidth, dataColWidth, rowHeight, fontSize, availableHeight, pageWidth, pageHeight) {
    const headerHeight = rowHeight;
    const maxRowsPerPage = Math.floor((availableHeight - headerHeight) / rowHeight);
    
    // Forcer la division en 2 pages maximum
    const totalSlots = relevantSlots.length;
    const midPoint = Math.ceil(totalSlots / 2);
    
    // Premi√®re page
    const firstPageSlots = relevantSlots.slice(0, midPoint);
    const firstPageMergeInfo = createPageMergeInfo(day, firstPageSlots, mergeInfo, 0);
    
    // Calculer la hauteur optimale pour la premi√®re page
    const firstPageRowHeight = Math.max(12, Math.floor(availableHeight / (firstPageSlots.length + 1)));
    const firstPageFontSize = Math.max(6, Math.min(10, firstPageRowHeight - 2));
    
    drawPlanningTableWithMerges(doc, day, firstPageSlots, firstPageMergeInfo, startY, timeColWidth, dataColWidth, firstPageRowHeight, firstPageFontSize);
    
    // Deuxi√®me page si n√©cessaire
    if (totalSlots > midPoint) {
        doc.addPage();
        
        // Titre de la deuxi√®me page
        doc.setFontSize(16);
        doc.setFont('helvetica', 'bold');
        doc.text(`${day.charAt(0).toUpperCase() + day.slice(1)} (2/2)`, pageWidth / 2, 30, { align: "center" });
        
        const secondPageSlots = relevantSlots.slice(midPoint);
        const secondPageMergeInfo = createPageMergeInfo(day, secondPageSlots, mergeInfo, midPoint);
        
        // Calculer la hauteur optimale pour la deuxi√®me page
        const secondPageRowHeight = Math.max(12, Math.floor(availableHeight / (secondPageSlots.length + 1)));
        const secondPageFontSize = Math.max(6, Math.min(10, secondPageRowHeight - 2));
        
        drawPlanningTableWithMerges(doc, day, secondPageSlots, secondPageMergeInfo, startY, timeColWidth, dataColWidth, secondPageRowHeight, secondPageFontSize);
    }
}


function createPageMergeInfo(day, pageSlots, originalMergeInfo, startIndex) {
    const pageMergeInfo = {};
    
    columns.forEach(col => {
        pageMergeInfo[col] = [];
        
        pageSlots.forEach((time, pageIndex) => {
            const originalIndex = startIndex + pageIndex;
            
            if (originalIndex < originalMergeInfo[col].length) {
                const originalMerge = originalMergeInfo[col][originalIndex];
                
                if (originalMerge && originalMerge.value) {
                    const originalStartRow = originalMerge.startRow;
                    const originalEndRow = originalStartRow + originalMerge.mergeLength - 1;
                    
                    // Calculer les limites visibles sur cette page
                    const pageStartIndex = startIndex;
                    const pageEndIndex = startIndex + pageSlots.length - 1;
                    
                    const visibleStart = Math.max(originalStartRow, pageStartIndex);
                    const visibleEnd = Math.min(originalEndRow, pageEndIndex);
                    
                    if (originalIndex >= visibleStart && originalIndex <= visibleEnd) {
                        pageMergeInfo[col][pageIndex] = {
                            isFirst: originalIndex === visibleStart,
                            isLast: originalIndex === visibleEnd,
                            mergeLength: visibleEnd - visibleStart + 1,
                            value: originalMerge.value,
                            startRow: visibleStart - startIndex,
                            isMerged: originalMerge.isMerged
                        };
                    }
                } else {
                    pageMergeInfo[col][pageIndex] = {
                        isFirst: true,
                        isLast: true,
                        mergeLength: 1,
                        value: '',
                        startRow: pageIndex,
                        isMerged: false
                    };
                }
            }
        });
    });
    
    return pageMergeInfo;
}


function analyzeMerges(day, relevantSlots) {

const mergeInfo = {};

columns.forEach(col => {

mergeInfo[col] = [];

let i = 0;


while (i < relevantSlots.length) {

const currentTime = relevantSlots[i];

const currentValue = planningData[day][currentTime][col];


if (currentValue && currentValue.trim() !== '') {

let mergeLength = 1;


// Compter les cr√©neaux cons√©cutifs avec la m√™me valeur

while (i + mergeLength < relevantSlots.length) {

const nextTime = relevantSlots[i + mergeLength];

const nextValue = planningData[day][nextTime][col];


if (nextValue === currentValue) {

mergeLength++;

} else {

break;

}

}


// Enregistrer les infos de fusion

for (let j = 0; j < mergeLength; j++) {

mergeInfo[col][i + j] = {

isFirst: j === 0,

isLast: j === mergeLength - 1,

mergeLength: mergeLength,

value: currentValue,

startRow: i,

isMerged: mergeLength > 1

};

}


i += mergeLength;

} else {

mergeInfo[col][i] = {

isFirst: true,

isLast: true,

mergeLength: 1,

value: '',

startRow: i,

isMerged: false

};

i++;

}
}

});

return mergeInfo;

}

function drawPlanningTableWithMerges(doc, day, relevantSlots, mergeInfo, startY, timeColWidth, dataColWidth, rowHeight, fontSize) {

let currentY = startY;
// Dessiner l'en-t√™te

doc.setFillColor(102, 126, 234); // Couleur de fond bleu

doc.rect(20, currentY, timeColWidth, rowHeight, 'F');


columns.forEach((col, index) => {

const x = 20 + timeColWidth + (index * dataColWidth);

doc.rect(x, currentY, dataColWidth, rowHeight, 'F');

});


// Texte de l'en-t√™te

doc.setTextColor(255, 255, 255); // Blanc

doc.setFont('helvetica', 'bold');

doc.setFontSize(fontSize + 1);


doc.text('Heure', 20 + timeColWidth/2, currentY + rowHeight/2 + 2, { align: 'center' });


columns.forEach((col, index) => {

const x = 20 + timeColWidth + (index * dataColWidth);

doc.text(col, x + dataColWidth/2, currentY + rowHeight/2 + 2, { align: 'center' });

});


currentY += rowHeight;


// Dessiner d'abord tous les arri√®re-plans des cellules fusionn√©es

relevantSlots.forEach((time, rowIndex) => {

columns.forEach((col, colIndex) => {

const merge = mergeInfo[col][rowIndex];

const x = 20 + timeColWidth + (colIndex * dataColWidth);

const y = startY + rowHeight + (rowIndex * rowHeight);


if (merge && merge.value && merge.isFirst) {

// Appliquer la couleur de fond selon l'activit√©

const color = getActivityColorRGB(merge.value);

if (color) {

const mergeHeight = rowHeight * merge.mergeLength;

doc.setFillColor(color.r, color.g, color.b);

doc.rect(x, y, dataColWidth, mergeHeight, 'F');

}

}

});

});


// Dessiner les lignes de donn√©es

doc.setFont('helvetica', 'normal');

doc.setFontSize(fontSize);


relevantSlots.forEach((time, rowIndex) => {

const y = startY + rowHeight + (rowIndex * rowHeight);


// Fond alternant pour la lisibilit√© (seulement pour la colonne heure)

if (rowIndex % 2 === 0) {

doc.setFillColor(248, 249, 250);

doc.rect(20, y, timeColWidth, rowHeight, 'F');

}


// Colonne heure

doc.setTextColor(0, 0, 0);

doc.setFont('helvetica', 'bold');

doc.text(time, 20 + timeColWidth/2, y + rowHeight/2 + 2, { align: 'center' });


// Colonnes de donn√©es avec fusion

doc.setFont('helvetica', 'bold');

columns.forEach((col, colIndex) => {

const merge = mergeInfo[col][rowIndex];

const x = 20 + timeColWidth + (colIndex * dataColWidth);


if (merge && merge.value) {

// D√©finir la couleur du texte

const color = getActivityColorRGB(merge.value);

if (color) {

doc.setTextColor(255, 255, 255); // Texte blanc sur fond color√©

} else {

doc.setTextColor(0, 0, 0); // Texte noir

}


// Afficher le texte seulement sur la premi√®re cellule de la fusion

if (merge.isFirst) {

const maxWidth = dataColWidth - 4;

const truncatedText = truncateText(doc, merge.value, maxWidth, fontSize);

const textY = y + (rowHeight * merge.mergeLength) / 2 + 2;

doc.text(truncatedText, x + dataColWidth/2, textY, { align: 'center' });

}

}

});

});


// Dessiner les bordures du tableau

doc.setDrawColor(0, 0, 0);

doc.setLineWidth(0.5);


// Bordures ext√©rieures

const tableWidth = timeColWidth + (columns.length * dataColWidth);

const tableHeight = (relevantSlots.length + 1) * rowHeight;

doc.rect(20, startY, tableWidth, tableHeight);


// Lignes verticales

doc.line(20 + timeColWidth, startY, 20 + timeColWidth, startY + tableHeight);

for (let i = 1; i < columns.length; i++) {

const x = 20 + timeColWidth + (i * dataColWidth);

doc.line(x, startY, x, startY + tableHeight);

}


// Lignes horizontales

for (let i = 1; i <= relevantSlots.length; i++) {

const y = startY + (i * rowHeight);


// Ligne compl√®te pour s√©parer les en-t√™tes

if (i === 1) {

doc.line(20, y, 20 + tableWidth, y);

} else {

// Ligne pour la colonne heure

doc.line(20, y, 20 + timeColWidth, y);


// Lignes pour chaque colonne de donn√©es (en √©vitant les zones fusionn√©es)

columns.forEach((col, colIndex) => {

const rowIndex = i - 2; // -1 pour l'en-t√™te, -1 pour l'index

if (rowIndex >= 0 && rowIndex < relevantSlots.length) {

const merge = mergeInfo[col][rowIndex];

const x = 20 + timeColWidth + (colIndex * dataColWidth);


// Dessiner la ligne seulement si c'est la derni√®re cellule d'une fusion ou pas de fusion

if (!merge || !merge.isMerged || merge.isLast) {

doc.line(x, y, x + dataColWidth, y);

}

} else if (i === relevantSlots.length + 1) {

// Derni√®re ligne du tableau

const x = 20 + timeColWidth + (colIndex * dataColWidth);

doc.line(x, y, x + dataColWidth, y);

}

});

}

}

}


// Gardez les autres fonctions inchang√©es

function getActivityColorRGB(value) {

const hex = getActivityColor(value);

if (!hex) return null;




return {

r: parseInt(hex.substr(1, 2), 16),

g: parseInt(hex.substr(3, 2), 16),

b: parseInt(hex.substr(5, 2), 16)

};




}


function truncateText(doc, text, maxWidth, fontSize) {

doc.setFontSize(fontSize);

const textWidth = doc.getTextWidth(text);




if (textWidth <= maxWidth) {

return text;

}


// Couper le texte et ajouter "..."

let truncated = text;

while (doc.getTextWidth(truncated + "...") > maxWidth && truncated.length > 0) {

truncated = truncated.slice(0, -1);

}


return truncated + "...";




}


function getActivityColor(value) {

if (!value) return null;

let key = value.toLowerCase()

.replace(/\s+/g, '-')

.replace('renfort-surveillance', 'renfort')

.replace('r√©fectoire', 'refectoire');

const activityColors = {

'bvs1': '#e91e63',

'bvs2': '#ff9800',

'portail': '#ff5722',

'voltige': '#2196f3',

'renfort': '#795548',

'cours-impaire': '#4caf50',

'cours-paire': '#8bc34a',

'etude-impaire': '#9c27b0',

'etude-paire': '#673ab7',

'ap': '#009688',

'hall': '#607d8b',

'refectoire': '#ff6f00',

'turbo': '#f44336',

'bureau-midi': '#3f51b5',

'pause': '#9e9e9e',

'marsons': '#00bcd4'

};

return activityColors[key] || null;

}
        document.addEventListener('DOMContentLoaded', function() {
    initializePlannings();
    initializeNames();
});
    </script>
</body>
</html>
