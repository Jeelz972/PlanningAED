<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G√©n√©rateur de Planning Excel</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5rem;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .tabs {
            display: flex;
            border-bottom: 3px solid #eee;
            margin-bottom: 20px;
            overflow-x: auto;
        }
        
        .tab {
            padding: 15px 25px;
            cursor: pointer;
            border: none;
            background: #f8f9fa;
            margin-right: 5px;
            border-radius: 10px 10px 0 0;
            font-weight: bold;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .tab:hover {
            background: #e9ecef;
            transform: translateY(-2px);
        }
        
        .tab.active {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.5s ease-in;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .planning-grid {
            display: grid;
            grid-template-columns: 80px repeat(7, 1fr);
            gap: 2px;
            background: #ddd;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        .planning-grid > div[style*="display: none"] {
    display: none !important;
}
        .time-slot {
            background: #f8f9fa;
            padding: 8px;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            border-right: 1px solid #ddd;
        }
        
        .planning-cell {
            background: white;
            padding: 5px;
            min-height: 25px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
        }
        
        .planning-cell:hover {
            transform: scale(1.02);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 10;
        }
        
        .planning-cell input {
            border: none;
            background: transparent;
            width: 100%;
            text-align: center;
            font-size: 11px;
            font-weight: bold;
            color: inherit;
        }
        
        .planning-cell input:focus {
            outline: 2px solid #667eea;
            border-radius: 3px;
        }
        
        .header-cell {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            font-weight: bold;
            text-align: center;
            padding: 12px;
            font-size: 14px;
        }
        
        /* Couleurs pour les postes */
        .bvs1 { background: #e91e63; color: white; }
        .bvs2 { background: #ff9800; color: white; }
        .portail { background: #ff5722; color: white; }
        .voltige { background: #2196f3; color: white; }
        .renfort { background: #795548; color: white; }
        .cours-impaire { background: #4caf50; color: white; }
        .cours-paire { background: #8bc34a; color: white; }
        .etude-impaire { background: #9c27b0; color: white; }
        .etude-paire { background: #673ab7; color: white; }
        .ap { background: #009688; color: white; }
        .hall { background: #607d8b; color: white; }
        .refectoire { background: #ff6f00; color: white; }
        .turbo { background: #f44336; color: white; }
        .bureau-midi { background: #3f51b5; color: white; }
        .pause { background: #9e9e9e; color: white; }
        .marsons { background: #00bcd4; color: white; }
        
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }
        
        .btn-success {
            background: linear-gradient(45deg, #4caf50, #45a049);
            color: white;
        }
        
        .btn-danger {
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
        }
        
        .activity-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .activity-btn {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 20px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            transition: all 0.2s ease;
            text-align: center;
        }
        
        .activity-btn:hover {
            transform: scale(1.05);
        }
        
        .activity-btn.selected {
            border-color: #667eea;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.3);
        }
        
        .legend {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .clear-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 12px;
        }
        .planning-table th, .planning-table td {
    border: 1px solid #ddd;
    padding: 4px;
    text-align: center;
}
        /* Tableau de synth√®se - bordures et responsive */
.synthese-responsive {
  width: 100%;
  overflow-x: auto;
  margin-bottom: 20px;
}

#synthese-table table {
  border-collapse: collapse;
  width: 100%;
  min-width: 400px;
}

#synthese-table th, #synthese-table td {
  border: 2px solid #764ba2;
  padding: 8px;
  text-align: center;
  background: #fff;
  font-size: 15px;
}

#synthese-table th {
  background: linear-gradient(45deg, #667eea, #764ba2);
  color: #fff;
}

@media (max-width: 700px) {
  #synthese-table th, #synthese-table td {
    padding: 4px;
    font-size: 11px;
  }
  #synthese-table table { min-width: 300px; }
}
    </style>
</head>
<body>
    <div class="container">
        <h1>üìÖ G√©n√©rateur de Planning Excel</h1>

        <div class="controls">
            <button class="btn btn-success" onclick="generateExcel()">üìä G√©n√©rer fichier Excel</button>
            <button class="btn btn-danger" onclick="clearAll()">üóëÔ∏è Effacer tout</button>
            
<!-- Bouton d'import -->
<input type="file" id="import-excel" accept=".xlsx,.xls" style="display:none" />
<button class="btn btn-primary" onclick="document.getElementById('import-excel').click()">Importer un fichier Excel</button>
        <div class="controls">
    <h3>Configuration des noms pour le PDF</h3>
    <div id="name-mapping" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 15px;">
        <!-- Les inputs seront g√©n√©r√©s dynamiquement -->
    </div>
    <button class="btn btn-primary" onclick="resetNames()">R√©initialiser les noms</button>
</div>
            <button class="btn btn-primary" onclick="generatePDF()">üñ®Ô∏è G√©n√©rer PDF imprimable</button>
        </div>
        <!-- √Ä ajouter dans la section <div class="controls"> apr√®s les autres boutons -->
<button class="btn btn-primary" onclick="generateIndividualPDF()">üë§ G√©n√©rer PDF individuel</button>
        
        <div class="activity-selector">
            <div class="activity-btn bvs1" onclick="selectActivity('BVS1')">B1</div>
            <div class="activity-btn bvs2" onclick="selectActivity('BVS2')">B2</div>
            <div class="activity-btn portail" onclick="selectActivity('Portail')">Portail</div>
            <div class="activity-btn voltige" onclick="selectActivity('Voltige')">Suivi de classe/accompagnement √©l√®ves/aide bureau</div>
            <div class="activity-btn renfort" onclick="selectActivity('Renfort surveillance')">Cours/WC/Hall</div>
            <div class="activity-btn cours-impaire" onclick="selectActivity('Cours Impaire')">Cours Impaire</div>
            <div class="activity-btn cours-paire" onclick="selectActivity('Cours paire')">Cours paire</div>
            <div class="activity-btn etude-impaire" onclick="selectActivity('Etude impaire')">Etude 1</div>
            <div class="activity-btn etude-paire" onclick="selectActivity('Etude paire')">Etude 2</div>
            <div class="activity-btn ap" onclick="selectActivity('AP')">Assistanat p√©dagogique</div>
            <div class="activity-btn hall" onclick="selectActivity('Hall')">Hall</div>
            <div class="activity-btn refectoire" onclick="selectActivity('R√©fectoire')">R√©fectoire</div>
            <div class="activity-btn turbo" onclick="selectActivity('Turbo')">Turbo</div>
            <div class="activity-btn bureau-midi" onclick="selectActivity('Bureau midi')">Bureau midi</div>
            <div class="activity-btn pause" onclick="selectActivity('Pause')">Pause</div>
            <div class="activity-btn marsons" onclick="selectActivity('Marsons')">Marsons</div>
        </div>

        <div class="clear-buttons">
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('BVS1')">‚ùå Effacer B1</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('BVS2')">‚ùå Effacer B2</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Portail')">‚ùå Effacer Portail</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Voltige')">‚ùå Effacer Voltige</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Renfort surveillance')">‚ùå Effacer Renforts</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Cours Impaire')">‚ùå Effacer Cours Impaire</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Cours paire')">‚ùå Effacer Cours paire</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Etude impaire')">‚ùå Effacer Etude 1</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Etude paire')">‚ùå Effacer Etude 2</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('AP')">‚ùå Effacer AP</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Hall')">‚ùå Effacer Hall</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('R√©fectoire')">‚ùå Effacer R√©fectoire</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Turbo')">‚ùå Effacer Turbo</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Bureau midi')">‚ùå Effacer Bureau midi</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Pause')">‚ùå Effacer Pause</button>
            <button class="btn btn-primary btn-small" onclick="clearSpecificPoste('Marsons')">‚ùå Effacer Marsons</button>
        </div>
        
        <div class="tabs">
            <div class="tab active" onclick="showTab('lundi')">Lundi</div>
            <div class="tab" onclick="showTab('mardi')">Mardi</div>
            <div class="tab" onclick="showTab('mercredi')">Mercredi</div>
            <div class="tab" onclick="showTab('jeudi')">Jeudi</div>
            <div class="tab" onclick="showTab('vendredi')">Vendredi</div>
            <div class="tab" onclick="showTab('synthese')">Synth√®se</div>
            <div class="tab" onclick="showTab('syntheseJour')">Synth√®se par jour</div>
        </div>
        
        <div id="lundi" class="tab-content active">
            <h3>Planning Lundi</h3>
            <div id="planning-lundi" class="planning-grid"></div>
        </div>
        
        <div id="mardi" class="tab-content">
            <h3>Planning Mardi</h3>
            <div id="planning-mardi" class="planning-grid"></div>
        </div>
        
        <div id="mercredi" class="tab-content">
            <h3>Planning Mercredi</h3>
            <div id="planning-mercredi" class="planning-grid"></div>
        </div>
        
        <div id="jeudi" class="tab-content">
            <h3>Planning Jeudi</h3>
            <div id="planning-jeudi" class="planning-grid"></div>
        </div>
        
        <div id="vendredi" class="tab-content">
            <h3>Planning Vendredi</h3>
            <div id="planning-vendredi" class="planning-grid"></div>
        </div>
        <div id="synthese" class="tab-content">
  <h3>Synth√®se du temps par poste et personne</h3>
  <div class="synthese-responsive"><div id="synthese-table"></div></div>
</div>
        <div id="syntheseJour" class="tab-content">
  <h3>Synth√®se Journalier par personne</h3>
  <div class="synthese-responsive"><div id="syntheseJour-table"></div></div>
</div>
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color bvs1"></div>
                <span>BVS1</span>
            </div>
            <div class="legend-item">
                <div class="legend-color bvs2"></div>
                <span>BVS2</span>
            </div>
            <div class="legend-item">
                <div class="legend-color portail"></div>
                <span>Portail</span>
            </div>
            <div class="legend-item">
                <div class="legend-color voltige"></div>
                <span>Suivi de classe/accompagnement √©l√®ves/aide bureau</span>
            </div>
            <div class="legend-item">
                <div class="legend-color renfort"></div>
                <span>Cours/WC/Hall</span>
            </div>
            <div class="legend-item">
                <div class="legend-color cours-impaire"></div>
                <span>Cours Impaire</span>
            </div>
            <div class="legend-item">
                <div class="legend-color cours-paire"></div>
                <span>Cours paire</span>
            </div>
            <div class="legend-item">
                <div class="legend-color etude-impaire"></div>
                <span>Etude impaire</span>
            </div>
            <div class="legend-item">
                <div class="legend-color etude-paire"></div>
                <span>Etude paire</span>
            </div>
            <div class="legend-item">
                <div class="legend-color ap"></div>
                <span>Assitanat p√©dagogique</span>
            </div>
            <div class="legend-item">
                <div class="legend-color hall"></div>
                <span>Hall</span>
            </div>
            <div class="legend-item">
                <div class="legend-color refectoire"></div>
                <span>R√©fectoire</span>
            </div>
            <div class="legend-item">
                <div class="legend-color turbo"></div>
                <span>Turbo</span>
            </div>
            <div class="legend-item">
                <div class="legend-color bureau-midi"></div>
                <span>Bureau midi</span>
            </div>
            <div class="legend-item">
                <div class="legend-color pause"></div>
                <span>Pause</span>
            </div>
            <div class="legend-item">
                <div class="legend-color marsons"></div>
                <span>Marsons</span>
            </div>
        </div>
    </div>

    <script>
        const timeSlots = [
    '07:25', '07:30','07:35', '07:40', '07:45', '07:50', '07:55', '08:00', '08:05', '08:10', '08:15',
    '08:20', '08:25', '08:30', '08:35', '08:40', '08:45', '08:50', '08:55', '09:00', '09:05',
    '09:10', '09:15', '09:20', '09:25', '09:30', '09:35', '09:40', '09:45', '09:50', '09:55',
    '10:00', '10:05', '10:10', '10:15', '10:20', '10:25', '10:30', '10:35', '10:40', '10:45',
    '10:50', '10:55', '11:00', '11:05', '11:10', '11:15', '11:20', '11:25', '11:30', '11:35',
    '11:40', '11:45', '11:50', '11:55', '12:00', '12:05', '12:10', '12:15', '12:20', '12:25',
    '12:30', '12:35', '12:40', '12:45', '12:50', '12:55', '13:00', '13:05', '13:10', '13:15',
    '13:20', '13:25', '13:30', '13:35', '13:40', '13:45', '13:50', '13:55', '14:00', '14:05',
    '14:10', '14:15', '14:20', '14:25', '14:30', '14:35', '14:40', '14:45', '14:50', '14:55',
    '15:00', '15:05', '15:10', '15:15', '15:20', '15:25', '15:30', '15:35', '15:40', '15:45',
    '15:50', '15:55', '16:00', '16:05', '16:10', '16:15', '16:20', '16:25', '16:30', '16:35',
    '16:40', '16:45', '16:50', '16:55', '17:00', '17:05', '17:10', '17:15', '17:20', '17:25',
    '17:30', '17:35'
];

const columns = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
const days = ['lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi'];

let selectedActivity = 'BVS1';
let isMouseDown = false;
let dragActivity = null;
let startDay = null;
let startCol = null;
let startRow = null;
let planningData = {};

// Table de correspondance pour l'affichage
const affichageMapping = {
  'Voltige': 'Suivi de classe/accompagnement √©l√®ves/aide bureau',
  'Renfort surveillance': 'Cours/WC/Hall'
};

const affichageReverseMapping = {
  'Suivi de classe/accompagnement √©l√®ves/aide bureau': 'Voltige',
  'Cours/WC/Hall': 'Renfort surveillance'
};

// Stockage des noms personnalis√©s
let customNames = {};
let colorMode = 'activity'; // 'activity' ou 'person'

// Initialiser les noms par d√©faut
function initializeNames() {
    columns.forEach(col => {
        if (!customNames[col]) {
            customNames[col] = col;
        }
    });
    updateNameInputs();
}

// Mettre √† jour les inputs de noms
function updateNameInputs() {
    const container = document.getElementById('name-mapping');
    container.innerHTML = '';
    
    columns.forEach(col => {
        const div = document.createElement('div');
        div.innerHTML = `
            <label for="name-${col}" style="display: block; font-weight: bold; margin-bottom: 5px;">
                Colonne ${col}:
            </label>
            <input type="text" 
                   id="name-${col}" 
                   value="${customNames[col] || col}" 
                   placeholder="Nom de la personne"
                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;"
                   onchange="updateCustomName('${col}', this.value)">
        `;
        container.appendChild(div);
    });
}

// Mettre √† jour un nom personnalis√©
function updateCustomName(col, name) {
    customNames[col] = name.trim() || col;
}

// R√©initialiser les noms aux valeurs par d√©faut
function resetNames() {
    columns.forEach(col => {
        customNames[col] = col;
    });
    updateNameInputs();
}

// Obtenir le nom d'affichage pour une colonne
function getDisplayName(col) {
    return customNames[col] || col;
}

function getAffichage(nom) {
  return affichageMapping[nom] || nom;
}

function getNomInterne(nom) {
  return affichageReverseMapping[nom] || nom;
}

// Initialiser les donn√©es de planning
days.forEach(day => {
    planningData[day] = {};
    timeSlots.forEach(time => {
        planningData[day][time] = {};
        columns.forEach(col => {
            planningData[day][time][col] = '';
        });
    });
});

document.addEventListener('mouseup', () => isMouseDown = false);

function initializePlannings() {
    days.forEach(day => {
        createPlanningGrid(day);
    });
}

function createPlanningGrid(day) {
    const container = document.getElementById(`planning-${day}`);
    container.innerHTML = '';
    
    // Headers
    container.appendChild(createCell('', 'header-cell'));
    columns.forEach(col => {
        container.appendChild(createCell(col, 'header-cell'));
    });
    
    // Time s and data
    timeSlots.forEach(time => {
        container.appendChild(createCell(time, 'time-slot'));
        columns.forEach(col => {
            const cell = createPlanningCell(day, time, col);
            container.appendChild(cell);
        });
    });
    
    mergeIdenticalCells(day);
}

function createCell(content, className) {
    const cell = document.createElement('div');
    cell.className = className;
    cell.textContent = content;
    return cell;
}

function createPlanningCell(day, time, col) {
    const cell = document.createElement('div');
    cell.className = 'planning-cell';

    const rowIdx = timeSlots.indexOf(time);
    const colIdx = columns.indexOf(col);

    cell.onmousedown = function(e) {
        isMouseDown = true;
        dragActivity = selectedActivity;
        startDay = day;
        startCol = col;
        startRow = rowIdx;
        updateCell(day, time, col, dragActivity, false);
        document.body.style.userSelect = "none";
    };
    
    cell.onmouseover = function(e) {
        if (isMouseDown && dragActivity && day === startDay && col === startCol) {
            let min = Math.min(startRow, rowIdx);
            let max = Math.max(startRow, rowIdx);
            for (let r = min; r <= max; r++) {
                let t = timeSlots[r];
                planningData[day][t][col] = dragActivity;
            }
            createPlanningGrid(day);
        }
    };
    
    cell.onmouseup = function(e) {
        isMouseDown = false;
        dragActivity = null;
        startDay = null;
        startCol = null;
        startRow = null;
        document.body.style.userSelect = "";
    };

    const input = document.createElement('input');
    input.type = 'text';
    input.value = getAffichage(planningData[day][time][col]);
    input.onchange = function() {
        planningData[day][time][col] = getNomInterne(this.value);
        updateCellAppearance(cell, this.value);
    };

    cell.appendChild(input);
    updateCellAppearance(cell, planningData[day][time][col]);
    return cell;
}

function updateCell(day, time, col, activity) {
    planningData[day][time][col] = activity;
    createPlanningGrid(day);
}

function updateCellAppearance(cell, value) {
    const activityClasses = ['bvs1', 'bvs2', 'portail', 'voltige', 'renfort', 'cours-impaire', 'cours-paire', 'etude-impaire', 'etude-paire', 'ap', 'hall', 'refectoire', 'turbo', 'bureau-midi', 'pause', 'marsons'];
    activityClasses.forEach(cls => cell.classList.remove(cls));
    
    if (value) {
        const activity = value.toLowerCase()
            .replace(/\s+/g, '-')
            .replace('renfort-surveillance', 'renfort')
            .replace('r√©fectoire', 'refectoire');
        if (activityClasses.includes(activity)) {
            cell.classList.add(activity);
        }
    }
}

function clearSpecificPoste(poste) {
    if (confirm(`√ätes-vous s√ªr de vouloir effacer tous les "${poste}" ?`)) {
        days.forEach(day => {
            timeSlots.forEach(time => {
                columns.forEach(col => {
                    if (planningData[day][time][col] === poste) {
                        planningData[day][time][col] = '';
                    }
                });
            });
            createPlanningGrid(day);
        });
    }
}

function selectActivity(activity) {
    selectedActivity = activity;
    document.querySelectorAll('.activity-btn').forEach(btn => {
        btn.classList.remove('selected');
    });
    event.target.classList.add('selected');
}

function showTab(day) {
    document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
    event.target.classList.add('active');
    document.getElementById(day).classList.add('active');
    if(day === 'synthese') {
        generateSynthesePersonneVolume();
    }
    if(day === 'syntheseJour') {
        generateSynthesePersonneParJour();
    }
}

function clearAll() {
    if (confirm('√ätes-vous s√ªr de vouloir effacer tous les plannings ?')) {
        days.forEach(day => {
            timeSlots.forEach(time => {
                columns.forEach(col => {
                    planningData[day][time][col] = '';
                });
            });
            createPlanningGrid(day);
        });
    }
}

function mergeIdenticalCells(day) {
    const rows = timeSlots.length;
    const cols = columns.length;
    const grid = document.getElementById('planning-' + day);
    if (!grid) return;

    const cellsMatrix = [];
    for (let col = 0; col < cols; col++) {
        cellsMatrix[col] = [];
        for (let row = 0; row < rows; row++) {
            const idx = (row + 1) * (cols + 1) + (col + 1);
            cellsMatrix[col][row] = grid.children[idx];
        }
    }

    for (let col = 0; col < cols; col++) {
        let start = 0;
        while (start < rows) {
            let end = start;
            while (
                end + 1 < rows &&
                planningData[day][timeSlots[end]][columns[col]] &&
                planningData[day][timeSlots[end]][columns[col]] === planningData[day][timeSlots[end + 1]][columns[col]]
            ) {
                end++;
            }
            if (end > start) {
                cellsMatrix[col][start].style.gridRow = `span ${end - start + 1}`;
                for (let r = start + 1; r <= end; r++) {
                    cellsMatrix[col][r].style.display = "none";
                }
            } else {
                cellsMatrix[col][start].style.gridRow = "";
                cellsMatrix[col][start].style.display = "";
            }
            start = end + 1;
        }
    }
}

function generateExcel() {
    const wb = XLSX.utils.book_new();

    const activityColors = {
        'bvs1': 'FFC91E63',
        'bvs2': 'FFFF9800',
        'portail': 'FFFF5722',
        'voltige': 'FF2196F3',
        'renfort': 'FF795548',
        'cours-impaire': 'FF4CAF50',
        'cours-paire': 'FF8BC34A',
        'etude-impaire': 'FF9C27B0',
        'etude-paire': 'FF673AB7',
        'ap': 'FF009688',
        'hall': 'FF607D8B',
        'refectoire': 'FFFF6F00',
        'turbo': 'FFF44336',
        'bureau-midi': 'FF3F51B5',
        'pause': 'FF9E9E9E',
        'marsons': 'FF00BCD4'
    };
    
    function getActivityKey(value) {
        if (!value) return null;
        let key = value.toLowerCase()
            .replace(/\s+/g, '-')
            .replace('renfort-surveillance', 'renfort')
            .replace('r√©fectoire', 'refectoire');
        return activityColors[key] ? key : null;
    }

    days.forEach(day => {
        const wsData = [];
        const headerRow = ['Heure', ...columns.map(col => getDisplayName(col))];
        wsData.push(headerRow);

        timeSlots.forEach(time => {
            const row = [time];
            columns.forEach(col => {
                row.push(planningData[day][time][col] || '');
            });
            wsData.push(row);
        });

        const ws = XLSX.utils.aoa_to_sheet(wsData);

        for(let r=1; r<wsData.length; r++) {
            for(let c=1; c<=columns.length; c++) {
                const value = wsData[r][c];
                const colorKey = getActivityKey(value);
                if (colorKey) {
                    const cellAddress = XLSX.utils.encode_cell({r, c});
                    if (!ws[cellAddress]) ws[cellAddress] = { t: 's', v: value };
                    ws[cellAddress].s = {
                        fill: { fgColor: { rgb: activityColors[colorKey] } },
                        font: { color: { rgb: "FFFFFFFF" }, bold: true }
                    };
                }
            }
        }

        ws['!merges'] = [];
        columns.forEach((col, colIdx) => {
            let start = 1;
            let value = wsData[start][colIdx + 1];
            for (let row = 2; row < wsData.length; row++) {
                if (wsData[row][colIdx + 1] !== value) {
                    if (row - start > 1 && value) {
                        ws['!merges'].push({ s: { r: start, c: colIdx + 1 }, e: { r: row - 1, c: colIdx + 1 } });
                    }
                    start = row;
                    value = wsData[row][colIdx + 1];
                }
            }
            if (wsData.length - start > 1 && value) {
                ws['!merges'].push({ s: { r: start, c: colIdx + 1 }, e: { r: wsData.length - 1, c: colIdx + 1 } });
            }
        });

        ws['!cols'] = [{ wch: 10 }];
        columns.forEach(() => ws['!cols'].push({ wch: 15 }));

        XLSX.utils.book_append_sheet(wb, ws, day.charAt(0).toUpperCase() + day.slice(1));
    });

    XLSX.writeFile(wb, 'planning_hebdomadaire.xlsx');
}

document.getElementById('import-excel').addEventListener('change', handleExcelImportAllDays);

function handleExcelImportAllDays(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: 'array' });
        const dayNames = ['lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi'];

        let changedDay = false;
        dayNames.forEach(day => {
            const sheetName = workbook.SheetNames.find(n => n.trim().toLowerCase() === day);
            if (!sheetName) return;
            const sheet = workbook.Sheets[sheetName];

            const merges = sheet['!merges'] || [];
            const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
            
            for (let i = 1; i < rows.length; i++) {
                const row = rows[i];
                const time = row[0];
                if (!planningData[day][time]) continue;
                for (let c = 0; c < columns.length; c++) {
                    planningData[day][time][columns[c]] = row[c + 1] || '';
                }
            }

            merges.forEach(merge => {
                const startRow = merge.s.r, endRow = merge.e.r;
                const startCol = merge.s.c, endCol = merge.e.c;
                const value = rows[startRow]?.[startCol] ?? '';
                
                for (let r = startRow; r <= endRow; r++) {
                    const time = rows[r]?.[0];
                    if (!planningData[day][time]) continue;
                    for (let c = startCol; c <= endCol; c++) {
                        if (c === 0) continue;
                        planningData[day][time][columns[c - 1]] = value;
                    }
                }
            });

            changedDay = true;
            createPlanningGrid(day);
        });

        if (changedDay) {
            alert("Importation termin√©e !");
        } else {
            alert("Aucune feuille nomm√©e 'lundi', 'mardi', etc. trouv√©e dans le fichier.");
        }
    };
    reader.readAsArrayBuffer(file);
}

function generateSynthesePersonneVolume() {
    const slotDuration = 5;
    const personMap = {};
    const itemMap = {};

    days.forEach(day => {
        timeSlots.forEach(time => {
            columns.forEach(col => {
                const value = planningData[day][time][col];
                if (value && value.trim() !== "") {
                    const personName = getDisplayName(col);
                    if (!personMap[personName]) personMap[personName] = {};
                    if (!personMap[personName][value]) personMap[personName][value] = 0;
                    personMap[personName][value] += 1;
                    
                    if (!itemMap[value]) itemMap[value] = [];
                    let personEntry = itemMap[value].find(entry => entry.col === personName);
                    if (personEntry) {
                        personEntry.nbre += 1;
                    } else {
                        itemMap[value].push({ col: personName, nbre: 1 });
                    }
                }
            });
        });
    });

    const allPeople = Object.keys(personMap).sort();
    const allItems = Object.keys(itemMap).sort();

    let html = `<table class="table table-bordered"><thead><tr><th>Personne</th>`;
    allItems.forEach(item => html += `<th>${item}</th>`);
    html += `<th>Total</th></tr></thead><tbody>`;

    allPeople.forEach(person => {
        let totalMinutes = 0;
        html += `<tr><td>${person}</td>`;
        allItems.forEach(item => {
            const count = personMap[person][item] || 0;
            const minutes = count * slotDuration;
            totalMinutes += minutes;
            
            const idCell = `id="${person.replace(/\s/g,'_')}+${item.replace(/\s/g,'_')}"`;
            html += `<td ${idCell}>${minutes > 0 ? formatHM(minutes) : ""}</td>`;
        });
        html += `<td><b>${totalMinutes > 0 ? formatHM(totalMinutes) : ""}</b></td></tr>`;
    });

    html += `</tbody></table>`;
    document.getElementById("synthese-table").innerHTML = html;
    colorerSyntheseParItem();
}

function formatHM(mins) {
    if (mins <= 0) return "";
    const h = Math.floor(mins / 60);
    const m = mins % 60;
    return h > 0 ? `${h}h${m > 0 ? m : ""}` : `${m}min`;
}

function generateSynthesePersonneParJour() {
    const slotDuration = 5;
    const personDayMap = {};

    days.forEach(day => {
        timeSlots.forEach(time => {
            columns.forEach(col => {
                const value = planningData[day][time][col];
                if (value && value.trim() !== "") {
                    const personName = getDisplayName(col);
                    if (!personDayMap[personName]) personDayMap[personName] = {};
                    if (!personDayMap[personName][day]) personDayMap[personName][day] = 0;
                    personDayMap[personName][day] += 1;
                }
            });
        });
    });

    const allPeople = Object.keys(personDayMap).sort();

    let html = `<table class="table table-bordered"><thead><tr><th>Personne</th>`;
    days.forEach(day => html += `<th>${day.charAt(0).toUpperCase() + day.slice(1)}</th>`);
    html += `<th>Total</th></tr></thead><tbody>`;

    allPeople.forEach(person => {
        let total = 0;
        html += `<tr><td>${person}</td>`;
        days.forEach(day => {
            const count = (personDayMap[person][day] || 0);
            const minutes = count * slotDuration;
            total += minutes;
            html += `<td>${minutes > 0 ? formatHM(minutes) : ""}</td>`;
        });
        html += `<td><b>${total > 0 ? formatHM(total) : ""}</b></td></tr>`;
    });

    html += `</tbody></table>`;
    document.getElementById("syntheseJour-table").innerHTML = html;
}

function colorerSyntheseParItem() {
    const table = document.querySelector('#synthese-table table');
    if (!table) return;
    const rows = Array.from(table.querySelectorAll('tbody tr'));
    if (rows.length === 0) return;

    const ths = Array.from(table.querySelectorAll('thead th'));
    const items = ths.slice(1, -1).map(th => th.textContent.trim());

    const excludeColsLabels = ['F', 'G'];
    const excludeIndexes = [];
    items.forEach((item, idx) => {
        if (excludeColsLabels.includes(item)) excludeIndexes.push(idx);
    });

    let moyennes = [];
    items.forEach((item, colIdx) => {
        if (excludeIndexes.includes(colIdx)) {
            moyennes[colIdx] = null;
            return;
        }
        let total = 0, count = 0;
        rows.forEach(row => {
            const cell = row.querySelectorAll('td')[colIdx + 1];
            if (!cell) return;
            let minutes = 0;
            let m = cell.textContent.match(/(\d+)h(\d+)?/);
            if (m) {
                minutes = parseInt(m[1]) * 60 + (m[2] ? parseInt(m[2]) : 0);
            } else {
                let m2 = cell.textContent.match(/(\d+)min/);
                if (m2) minutes = parseInt(m2[1]);
            }
            if (minutes > 0) {
                total += minutes;
                count++;
            }
        });
        moyennes[colIdx] = count ? total / count : 0;
    });

    rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        items.forEach((item, colIdx) => {
            if (excludeIndexes.includes(colIdx)) {
                const cell = cells[colIdx + 1];
                if (cell) {
                    cell.style.backgroundColor = '';
                    cell.style.fontWeight = '';
                }
                return;
            }
            const cell = cells[colIdx + 1];
            if (!cell) return;
            let minutes = 0;
            let m = cell.textContent.match(/(\d+)h(\d+)?/);
            if (m) {
                minutes = parseInt(m[1]) * 60 + (m[2] ? parseInt(m[2]) : 0);
            } else {
                let m2 = cell.textContent.match(/(\d+)min/);
                if (m2) minutes = parseInt(m2[1]);
            }
            let moyenne = moyennes[colIdx] || 0;
            let color = '';
            let ecart = minutes - moyenne;
            if (minutes > 0 && Math.abs(ecart) > 60) {
                if (ecart > 60) {
                    let intensite = Math.min((ecart - 60) / (moyenne || 1), 1);
                    color = `rgba(138, 43, 226, ${0.3 + 0.7 * intensite})`;
                } else if (ecart < -60) {
                    let intensite = Math.min((-ecart - 60) / (moyenne || 1), 1);
                    color = `rgba(255, 140, 0, ${0.3 + 0.7 * intensite})`;
                }
                cell.style.backgroundColor = color;
                cell.style.fontWeight = "bold";
            } else {
                cell.style.backgroundColor = '';
                cell.style.fontWeight = '';
            }
        });
    });
}

function setColorMode(mode) {
    colorMode = mode;
}

// === FONCTIONS PDF OPTIMIS√âES (avec compression et fusion) ===

function generatePDF(selectedColorMode = 'person') {
    colorMode = selectedColorMode;
    
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('l', 'pt', 'a4');
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();

    let isFirstPage = true;

    days.forEach((day, dayIndex) => {
        if (!isFirstPage) {
            doc.addPage();
        }
        isFirstPage = false;

        const compressedSlots = compressTimeSlots(day);

        if (compressedSlots.length === 0) {
            doc.setFontSize(14);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(0, 0, 0);
            doc.text(day.charAt(0).toUpperCase() + day.slice(1), 20, 40);
            
            doc.setFontSize(12);
            doc.setFont('helvetica', 'normal');
            doc.text("Aucune donn√©e pour ce jour", 20, 60);
            return;
        }

        const mergeInfo = analyzeMergesOptimized(day, compressedSlots);
        const startY = 60;
        const availableHeight = pageHeight - startY - 20;
        const availableWidth = pageWidth - 40;

        const totalRows = compressedSlots.length + 1;
        const minRowHeight = 12;
        const rowHeight = Math.max(minRowHeight, Math.floor(availableHeight / totalRows));
        const fontSize = Math.max(6, Math.min(10, rowHeight - 2));

        const timeColWidth = 80;
        const dataColWidth = (availableWidth - timeColWidth) / columns.length;

        const totalTableHeight = totalRows * rowHeight;

        if (totalTableHeight > availableHeight) {
            drawOptimizedPlanningWithPagination(doc, day, compressedSlots, mergeInfo, startY, timeColWidth, dataColWidth, minRowHeight, fontSize, availableHeight, pageWidth, pageHeight);
        } else {
            drawPlanningTableWithMerges(doc, day, compressedSlots, mergeInfo, startY, timeColWidth, dataColWidth, rowHeight, fontSize);
        }
    });

    const filename = `planning_hebdomadaire_${colorMode}.pdf`;
    doc.save(filename);
}
function compressTimeSlots(day) {
    const compressedSlots = [];
    let currentSlot = null;

    timeSlots.forEach((time, index) => {
        const hasData = columns.some(col => {
            const value = planningData[day][time][col];
            return value && value.trim() !== '';
        });

        if (hasData) {
            if (currentSlot) {
                const canMerge = canMergeWithPrevious(day, currentSlot, time);
                if (canMerge) {
                    currentSlot.endTime = time;
                    currentSlot.timeSlots.push(time);
                } else {
                    compressedSlots.push(currentSlot);
                    currentSlot = {
                        startTime: time,
                        endTime: time,
                        timeSlots: [time],
                        displayLabel: time
                    };
                }
            } else {
                currentSlot = {
                    startTime: time,
                    endTime: time,
                    timeSlots: [time],
                    displayLabel: time
                };
            }
        } else if (currentSlot) {
            compressedSlots.push(currentSlot);
            currentSlot = null;
        }
    });

    if (currentSlot) {
        compressedSlots.push(currentSlot);
    }

    compressedSlots.forEach(slot => {
        const endTimeWith5Min = addMinutesToTime(slot.endTime, 5);
        slot.displayLabel = `${slot.startTime} - ${endTimeWith5Min}`;
    });

    return compressedSlots;
}

function canMergeWithPrevious(day, currentSlot, newTime) {
    const lastTimeInSlot = currentSlot.timeSlots[currentSlot.timeSlots.length - 1];
    return columns.every(col => {
        const lastValue = planningData[day][lastTimeInSlot][col] || '';
        const newValue = planningData[day][newTime][col] || '';
        return lastValue.trim() === newValue.trim();
    });
}

function analyzeMergesOptimized(day, compressedSlots) {
    const mergeInfo = {};
    
    columns.forEach(col => {
        mergeInfo[col] = [];
        let i = 0;
        
        while (i < compressedSlots.length) {
            const currentSlot = compressedSlots[i];
            const currentValue = getCurrentSlotValue(day, currentSlot, col);
            
            if (currentValue && currentValue.trim() !== '') {
                let mergeLength = 1;
                
                while (i + mergeLength < compressedSlots.length) {
                    const nextSlot = compressedSlots[i + mergeLength];
                    const nextValue = getCurrentSlotValue(day, nextSlot, col);
                    if (nextValue === currentValue) {
                        mergeLength++;
                    } else {
                        break;
                    }
                }
                
                for (let j = 0; j < mergeLength; j++) {
                    mergeInfo[col][i + j] = {
                        isFirst: j === 0,
                        isLast: j === mergeLength - 1,
                        mergeLength: mergeLength,
                        value: currentValue,
                        startRow: i,
                        isMerged: mergeLength > 1
                    };
                }
                i += mergeLength;
            } else {
                mergeInfo[col][i] = {
                    isFirst: true,
                    isLast: true,
                    mergeLength: 1,
                    value: '',
                    startRow: i,
                    isMerged: false
                };
                i++;
            }
        }
    });
    
    return mergeInfo;
}

function getCurrentSlotValue(day, slot, col) {
    return planningData[day][slot.startTime][col] || '';
}

function drawPlanningTableWithMerges(doc, day, compressedSlots, mergeInfo, startY, timeColWidth, dataColWidth, rowHeight, fontSize) {
    let currentY = startY;

    // Titre du jour
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(0, 0, 0);
    doc.text(day.charAt(0).toUpperCase() + day.slice(1), 20, currentY - 10);

    // Dessiner l'en-t√™te
    doc.setFillColor(102, 126, 234);
    doc.rect(20, currentY, timeColWidth, rowHeight, 'F');
    columns.forEach((col, index) => {
        const x = 20 + timeColWidth + (index * dataColWidth);
        doc.rect(x, currentY, dataColWidth, rowHeight, 'F');
    });

    // Texte de l'en-t√™te
    doc.setTextColor(255, 255, 255);
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(fontSize + 1);
    doc.text('Horaires', 20 + timeColWidth/2, currentY + rowHeight/2 + 2, { align: 'center' });
    
    columns.forEach((col, index) => {
        const x = 20 + timeColWidth + (index * dataColWidth);
        const displayName = getDisplayName(col);
        const truncatedName = truncateText(doc, displayName, dataColWidth - 4, fontSize + 1);
        doc.text(truncatedName, x + dataColWidth/2, currentY + rowHeight/2 + 2, { align: 'center' });
    });

    currentY += rowHeight;

    // Dessiner les arri√®re-plans des cellules fusionn√©es
    compressedSlots.forEach((slot, rowIndex) => {
        columns.forEach((col, colIndex) => {
            const merge = mergeInfo[col][rowIndex];
            const x = 20 + timeColWidth + (colIndex * dataColWidth);
            const y = startY + rowHeight + (rowIndex * rowHeight);
            
            if (merge && merge.value && merge.isFirst) {
                const color = getCellColor(merge.value, col);
                if (color) {
                    const mergeHeight = rowHeight * merge.mergeLength;
                    doc.setFillColor(color.r, color.g, color.b);
                    doc.rect(x, y, dataColWidth, mergeHeight, 'F');
                }
            }
        });
    });

    // Dessiner les lignes de donn√©es
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(fontSize);

    compressedSlots.forEach((slot, rowIndex) => {
        const y = startY + rowHeight + (rowIndex * rowHeight);

        // Fond alternant pour la colonne horaire
        if (rowIndex % 2 === 0) {
            doc.setFillColor(248, 249, 250);
            doc.rect(20, y, timeColWidth, rowHeight, 'F');
        }

        // Colonne horaire
        doc.setTextColor(0, 0, 0);
        doc.setFont('helvetica', 'bold');
        const truncatedTime = truncateText(doc, slot.displayLabel, timeColWidth - 4, fontSize);
        doc.text(truncatedTime, 20 + timeColWidth/2, y + rowHeight/2 + 2, { align: 'center' });

        // Colonnes de donn√©es
        doc.setFont('helvetica', 'bold');
        columns.forEach((col, colIndex) => {
            const merge = mergeInfo[col][rowIndex];
            const x = 20 + timeColWidth + (colIndex * dataColWidth);

            if (merge && merge.value && merge.isFirst) {
                const color = getCellColor(merge.value, col);
                if (color) {
                    doc.setTextColor(255, 255, 255);
                } else {
                    doc.setTextColor(0, 0, 0);
                }

                const maxWidth = dataColWidth - 4;
                const truncatedText = truncateText(doc, merge.value, maxWidth, fontSize);
                const textY = y + (rowHeight * merge.mergeLength) / 2 + 2;
                doc.text(truncatedText, x + dataColWidth/2, textY, { align: 'center' });
            }
        });
    });

    drawTableBorders(doc, startY, timeColWidth, dataColWidth, rowHeight, compressedSlots.length + 1, columns.length, mergeInfo, compressedSlots);
}

function getCellColor(value, columnName) {
    if (!value) return null;
    
    if (colorMode === 'person') {
        return getPersonColorRGB(columnName);
    } else {
        return getActivityColorRGB(value);
    }
}

function addMinutesToTime(timeStr, minutesToAdd) {
    const [hours, minutes] = timeStr.split(':').map(Number);
    const date = new Date(0, 0, 0, hours, minutes + minutesToAdd, 0);
    const h = String(date.getHours()).padStart(2, '0');
    const m = String(date.getMinutes()).padStart(2, '0');
    return `${h}:${m}`;
}

function drawTableBorders(doc, startY, timeColWidth, dataColWidth, rowHeight, totalRows, totalCols, mergeInfo, compressedSlots) {
    doc.setDrawColor(0, 0, 0);
    doc.setLineWidth(0.5);

    // Bordures ext√©rieures
    const tableWidth = timeColWidth + (totalCols * dataColWidth);
    const tableHeight = totalRows * rowHeight;
    doc.rect(20, startY, tableWidth, tableHeight);

    // Lignes verticales
    doc.line(20 + timeColWidth, startY, 20 + timeColWidth, startY + tableHeight);
    for (let i = 1; i < totalCols; i++) {
        const x = 20 + timeColWidth + (i * dataColWidth);
        doc.line(x, startY, x, startY + tableHeight);
    }

    // Lignes horizontales
    for (let i = 1; i <= compressedSlots.length; i++) {
        const y = startY + (i * rowHeight);
        
        if (i === 1) {
            doc.line(20, y, 20 + tableWidth, y);
        } else {
            doc.line(20, y, 20 + timeColWidth, y);
            
            columns.forEach((col, colIndex) => {
                const rowIndex = i - 2;
                if (rowIndex >= 0 && rowIndex < compressedSlots.length) {
                    const merge = mergeInfo[col][rowIndex];
                    const x = 20 + timeColWidth + (colIndex * dataColWidth);
                    
                    if (!merge || !merge.isMerged || merge.isLast) {
                        doc.line(x, y, x + dataColWidth, y);
                    }
                } else if (i === compressedSlots.length + 1) {
                    const x = 20 + timeColWidth + (colIndex * dataColWidth);
                    doc.line(x, y, x + dataColWidth, y);
                }
            });
        }
    }
}

function drawOptimizedPlanningWithPagination(doc, day, compressedSlots, mergeInfo, startY, timeColWidth, dataColWidth, rowHeight, fontSize, availableHeight, pageWidth, pageHeight) {
    const totalSlots = compressedSlots.length;
    const midPoint = Math.ceil(totalSlots / 2);

    const firstPageSlots = compressedSlots.slice(0, midPoint);
    const firstPageMergeInfo = createPageMergeInfo(day, firstPageSlots, mergeInfo, 0);
    const firstPageRowHeight = Math.max(12, Math.floor(availableHeight / (firstPageSlots.length + 1)));
    const firstPageFontSize = Math.max(6, Math.min(10, firstPageRowHeight - 2));

    drawPlanningTableWithMerges(doc, day, firstPageSlots, firstPageMergeInfo, startY, timeColWidth, dataColWidth, firstPageRowHeight, firstPageFontSize);

    if (totalSlots > midPoint) {
        doc.addPage();
        
        const secondPageSlots = compressedSlots.slice(midPoint);
        const secondPageMergeInfo = createPageMergeInfo(day, secondPageSlots, mergeInfo, midPoint);
        const secondPageRowHeight = Math.max(12, Math.floor(availableHeight / (secondPageSlots.length + 1)));
        const secondPageFontSize = Math.max(6, Math.min(10, secondPageRowHeight - 2));

        drawPlanningTableWithMerges(doc, `${day} (suite)`, secondPageSlots, secondPageMergeInfo, startY, timeColWidth, dataColWidth, secondPageRowHeight, secondPageFontSize);
    }
}

function createPageMergeInfo(day, pageSlots, originalMergeInfo, startIndex) {
    const pageMergeInfo = {};

    columns.forEach(col => {
        pageMergeInfo[col] = [];
        
        pageSlots.forEach((time, pageIndex) => {
            const originalIndex = startIndex + pageIndex;
            
            if (originalIndex < originalMergeInfo[col].length) {
                const originalMerge = originalMergeInfo[col][originalIndex];
                
                if (originalMerge && originalMerge.value) {
                    const originalStartRow = originalMerge.startRow;
                    const originalEndRow = originalStartRow + originalMerge.mergeLength - 1;
                    const pageStartIndex = startIndex;
                    const pageEndIndex = startIndex + pageSlots.length - 1;
                    
                    const visibleStart = Math.max(originalStartRow, pageStartIndex);
                    const visibleEnd = Math.min(originalEndRow, pageEndIndex);
                    
                    if (originalIndex >= visibleStart && originalIndex <= visibleEnd) {
                        pageMergeInfo[col][pageIndex] = {
                            isFirst: originalIndex === visibleStart,
                            isLast: originalIndex === visibleEnd,
                            mergeLength: visibleEnd - visibleStart + 1,
                            value: originalMerge.value,
                            startRow: visibleStart - startIndex,
                            isMerged: originalMerge.isMerged
                        };
                    }
                } else {
                    pageMergeInfo[col][pageIndex] = {
                        isFirst: true,
                        isLast: true,
                        mergeLength: 1,
                        value: '',
                        startRow: pageIndex,
                        isMerged: false
                    };
                }
            }
        });
    });

    return pageMergeInfo;
}

function getActivityColorRGB(value) {
    const hex = getActivityColor(value);
    if (!hex) return null;
    
    return {
        r: parseInt(hex.substr(1, 2), 16),
        g: parseInt(hex.substr(3, 2), 16),
        b: parseInt(hex.substr(5, 2), 16)
    };
}

function getPersonColorRGB(personne) {
    const hex = getCouleurPourPersonne(personne);
    if (!hex) return null;
    
    return {
        r: parseInt(hex.substr(1, 2), 16),
        g: parseInt(hex.substr(3, 2), 16),
        b: parseInt(hex.substr(5, 2), 16)
    };
}

function getActivityColor(value) {
    if (!value) return null;
    
    let key = value.toLowerCase()
        .replace(/\s+/g, '-')
        .replace('renfort-surveillance', 'renfort')
        .replace('r√©fectoire', 'refectoire');

    const activityColors = {
        'bvs1': '#e91e63',
        'bvs2': '#ff9800',
        'portail': '#ff5722',
        'voltige': '#2196f3',
        'renfort': '#795548',
        'cours-impaire': '#4caf50',
        'cours-paire': '#8bc34a',
        'etude-impaire': '#9c27b0',
        'etude-paire': '#673ab7',
        'ap': '#009688',
        'hall': '#607d8b',
        'refectoire': '#ff6f00',
        'turbo': '#f44336',
        'bureau-midi': '#3f51b5',
        'pause': '#9e9e9e',
        'marsons': '#00bcd4'
    };

    return activityColors[key] || null;
}

function getCouleurPourPersonne(personne) {
    const couleursPersonnes = {
        'a': "#FF5733",
        'b': "#33C1FF", 
        'c': "#008000",
        'd': "#d58490",
        'e': "#FF33A8",
        'f': "#29f0a5",
        'g': "#A833FF"
    };
    
    return couleursPersonnes[personne.toLowerCase()] || "#CCCCCC";
}

function truncateText(doc, text, maxWidth, fontSize) {
    doc.setFontSize(fontSize);
    const textWidth = doc.getTextWidth(text);
    
    if (textWidth <= maxWidth) {
        return text;
    }

    let truncated = text;
    while (doc.getTextWidth(truncated + "...") > maxWidth && truncated.length > 0) {
        truncated = truncated.slice(0, -1);
    }
    return truncated + "...";
}

// Fonction pour changer le mode de coloration
function setColorMode(mode) {
    colorMode = mode;
}

// Fonction principale de g√©n√©ration PDF avec choix de mode
function generatePDF(selectedColorMode = 'person') {
    colorMode = selectedColorMode;
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('l', 'pt', 'a4');
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();

    let isFirstPage = true;

    days.forEach((day, dayIndex) => {
        if (!isFirstPage) {
            doc.addPage();
        }
        isFirstPage = false;

        const compressedSlots = compressTimeSlots(day);
        
        if (compressedSlots.length === 0) {
            doc.setFontSize(14);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(0, 0, 0);
            doc.text(day.charAt(0).toUpperCase() + day.slice(1), 20, 40);
            doc.setFontSize(12);
            doc.setFont('helvetica', 'normal');
            doc.text("Aucune donn√©e pour ce jour", 20, 60);
            return;
        }

        const mergeInfo = analyzeMergesOptimized(day, compressedSlots);
        const startY = 60;
        const availableHeight = pageHeight - startY - 20;
        const availableWidth = pageWidth - 40;
        const totalRows = compressedSlots.length + 1;
        const minRowHeight = 12;
        const rowHeight = Math.max(minRowHeight, Math.floor(availableHeight / totalRows));
        const fontSize = Math.max(6, Math.min(10, rowHeight - 2));
        const timeColWidth = 80;
        const dataColWidth = (availableWidth - timeColWidth) / columns.length;
        const totalTableHeight = totalRows * rowHeight;

        if (totalTableHeight > availableHeight) {
            drawOptimizedPlanningWithPagination(doc, day, compressedSlots, mergeInfo, startY, timeColWidth, dataColWidth, minRowHeight, fontSize, availableHeight, pageWidth, pageHeight);
        } else {
            drawPlanningTableWithMerges(doc, day, compressedSlots, mergeInfo, startY, timeColWidth, dataColWidth, rowHeight, fontSize);
        }
    });

    const filename = `planning_hebdomadaire_${colorMode}.pdf`;
    doc.save(filename);
}

function generatePDFByActivity() {
    generatePDF('activity');
}

function generatePDFByPerson() {
    generatePDF('person');
}

function generateAllDaysPDF(selectedColorMode = 'activity') {
    colorMode = selectedColorMode;
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('l', 'pt', 'a4');
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();

    let isFirstPage = true;

    days.forEach((day, dayIndex) => {
        if (!isFirstPage) {
            doc.addPage();
        }
        isFirstPage = false;

        doc.setFontSize(18);
        doc.setFont('helvetica', 'bold');
        doc.text(`${day.charAt(0).toUpperCase() + day.slice(1)} (${dayIndex + 1}/${days.length})`, pageWidth / 2, 30, { align: "center" });

        const compressedSlots = compressTimeSlots(day);
        
        if (compressedSlots.length === 0) {
            doc.setFontSize(12);
            doc.setFont('helvetica', 'normal');
            doc.text("Aucune donn√©e pour ce jour", pageWidth / 2, pageHeight / 2, { align: "center" });
            return;
        }

        const mergeInfo = analyzeMergesOptimized(day, compressedSlots);
        const startY = 60;
        const availableHeight = pageHeight - startY - 20;
        const availableWidth = pageWidth - 40;
        const totalRows = compressedSlots.length + 1;
        const minRowHeight = 12;
        const rowHeight = Math.max(minRowHeight, Math.floor(availableHeight / totalRows));
        const fontSize = Math.max(6, Math.min(10, rowHeight - 2));
        const timeColWidth = 80;
        const dataColWidth = (availableWidth - timeColWidth) / columns.length;
        const totalTableHeight = totalRows * rowHeight;

        if (totalTableHeight > availableHeight) {
            drawOptimizedPlanningWithPagination(doc, day, compressedSlots, mergeInfo, startY, timeColWidth, dataColWidth, minRowHeight, fontSize, availableHeight, pageWidth, pageHeight);
        } else {
            drawPlanningTableWithMerges(doc, day, compressedSlots, mergeInfo, startY, timeColWidth, dataColWidth, rowHeight, fontSize);
        }
    });

    const filename = `planning_complet_${colorMode}.pdf`;
    doc.save(filename);
}

// Initialisation au chargement de la page
document.addEventListener('DOMContentLoaded', function() {
    initializePlannings();
    initializeNames();
});
       function generateIndividualPDF() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('l', 'pt', 'a4'); // Format paysage
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    
    let isFirstPage = true;
    
    // Pour chaque personne (colonne)
    columns.forEach((col, personIndex) => {
        const personName = getDisplayName(col);
        const personSchedule = getPersonSchedule(col);
        
        // V√©rifier si la personne a au moins une activit√© dans la semaine
        if (!hasAnyActivity(personSchedule)) {
            return; // Passer √† la personne suivante si aucune activit√©
        }
        
        if (!isFirstPage) {
            doc.addPage();
        }
        isFirstPage = false;
        
        // Titre de la page avec le nom de la personne
        doc.setFontSize(16);
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(0, 0, 0);
        doc.text(`Emploi du temps - ${personName}`, pageWidth / 2, 30, { align: 'center' });
        
        // Date de g√©n√©ration
        doc.setFontSize(9);
        doc.setFont('helvetica', 'normal');
        doc.setTextColor(100, 100, 100);
        const today = new Date();
        doc.text(`G√©n√©r√© le ${today.toLocaleDateString('fr-FR')}`, pageWidth / 2, 42, { align: 'center' });
        
        // Dessiner tous les jours en colonnes
        drawAllDaysForPerson(doc, personSchedule, col, pageWidth, pageHeight);
        
        // Ajouter un r√©sum√© en bas de page
        drawPersonSummaryBottom(doc, personSchedule, pageHeight - 40, pageWidth);
    });
    
    // Sauvegarder le PDF
    const filename = `emplois_du_temps_individuels.pdf`;
    doc.save(filename);
}

function drawAllDaysForPerson(doc, personSchedule, col, pageWidth, pageHeight) {
    const startY = 55;
    const margin = 15;
    const columnSpacing = 10;
    const availableWidth = pageWidth - (2 * margin);
    const columnWidth = (availableWidth - (4 * columnSpacing)) / 5; // 5 jours
    
    let maxHeight = 0;
    const dayData = [];
    
    // Pr√©parer les donn√©es compress√©es pour chaque jour
    days.forEach(day => {
        const compressed = compressPersonTimeSlots(day, col);
        dayData.push({
            day: day,
            slots: compressed
        });
        
        // Calculer la hauteur n√©cessaire pour ce jour (augment√©e pour plus d'espace)
        const dayHeight = (compressed.length + 1) * 28; // Augment√© de 20 √† 28 pour plus d'espace
        if (dayHeight > maxHeight) {
            maxHeight = dayHeight;
        }
    });
    
    // Limiter la hauteur maximale
    const maxAvailableHeight = pageHeight - startY - 60;
    const actualHeight = Math.min(maxHeight, maxAvailableHeight);
    
    // Dessiner chaque jour dans sa colonne
    days.forEach((day, dayIndex) => {
        const x = margin + (dayIndex * (columnWidth + columnSpacing));
        const compressed = compressPersonTimeSlots(day, col);
        
        if (compressed.length > 0) {
            drawDayColumn(doc, day, compressed, x, startY, columnWidth, actualHeight);
        } else {
            // Jour sans activit√© - juste afficher le titre
            drawEmptyDayColumn(doc, day, x, startY, columnWidth);
        }
    });
}

function drawDayColumn(doc, day, compressedSlots, x, y, width, maxHeight) {
    const headerHeight = 22;
    const availableHeight = maxHeight || 400;
    const totalSlots = compressedSlots.length;
    // Augmenter la hauteur des lignes pour plus d'espace
    const rowHeight = Math.min(26, Math.max(18, (availableHeight - headerHeight) / totalSlots));
    const fontSize = Math.min(8, Math.max(6, rowHeight / 3.5)); // Ajust√© pour tenir compte de l'espace suppl√©mentaire
    
    // En-t√™te du jour
    doc.setFillColor(102, 126, 234);
    doc.rect(x, y, width, headerHeight, 'F');
    doc.setTextColor(255, 255, 255);
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(10);
    doc.text(day.charAt(0).toUpperCase() + day.slice(1), x + width/2, y + headerHeight/2 + 3, { align: 'center' });
    
    // Tableau des activit√©s
    let currentY = y + headerHeight;
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(fontSize);
    
    compressedSlots.forEach((slot, index) => {
        // Alterner les couleurs de fond
        if (index % 2 === 0) {
            doc.setFillColor(248, 249, 250);
            doc.rect(x, currentY, width, rowHeight, 'F');
        }
        
        // Couleur de l'activit√©
        const activityColor = getActivityColorRGB(slot.activity);
        if (activityColor) {
            doc.setFillColor(activityColor.r, activityColor.g, activityColor.b);
            doc.rect(x + 1, currentY + 1, width - 2, rowHeight - 2, 'F');
            doc.setTextColor(255, 255, 255);
            doc.setFont('helvetica', 'bold');
        } else {
            doc.setTextColor(0, 0, 0);
            doc.setFont('helvetica', 'normal');
        }
        
        // Calculer les positions verticales avec espacement
        const topSpacing = rowHeight * 0.20;    // 20% depuis le haut
        const middleSpacing = rowHeight * 0.50; // 50% (centre)
        const bottomSpacing = rowHeight * 0.80; // 80% depuis le haut
        
        // Horaires (en haut avec plus d'espace)
        const endTimeWith5Min = addMinutesToTime(slot.endTime, 5);
        const timeText = `${slot.startTime} - ${endTimeWith5Min}`; // Ajout d'espaces autour du tiret
        
        doc.setFontSize(fontSize - 1);
        if (activityColor) {
            doc.setTextColor(255, 255, 255);
        } else {
            doc.setTextColor(60, 60, 60);
        }
        doc.text(timeText, x + width/2, currentY + topSpacing, { align: 'center' });
        
        // Activit√© (au milieu avec bon espacement)
        doc.setFontSize(fontSize);
        if (activityColor) {
            doc.setTextColor(255, 255, 255);
            doc.setFont('helvetica', 'bold');
        } else {
            doc.setTextColor(0, 0, 0);
            doc.setFont('helvetica', 'normal');
        }
        const activityText = truncateText(doc, slot.activity, width - 6, fontSize);
        doc.text(activityText, x + width/2, currentY + middleSpacing, { align: 'center' });
        
        // Dur√©e (en bas avec espacement)
        const durationText = `( ${formatDuration(slot.duration)} )`; // Ajout d'espaces dans les parenth√®ses
        doc.setFontSize(fontSize - 2);
        if (activityColor) {
            doc.setTextColor(255, 255, 255, 0.9);
        } else {
            doc.setTextColor(100, 100, 100);
        }
        doc.setFont('helvetica', 'normal');
        doc.text(durationText, x + width/2, currentY + bottomSpacing, { align: 'center' });
        
        currentY += rowHeight;
    });
    
    // Bordures du tableau
    doc.setDrawColor(200, 200, 200);
    doc.setLineWidth(0.5);
    const tableHeight = headerHeight + (totalSlots * rowHeight);
    doc.rect(x, y, width, tableHeight);
    doc.line(x, y + headerHeight, x + width, y + headerHeight);
}

function drawEmptyDayColumn(doc, day, x, y, width) {
    const headerHeight = 22;
    
    // En-t√™te du jour
    doc.setFillColor(200, 200, 200);
    doc.rect(x, y, width, headerHeight, 'F');
    doc.setTextColor(255, 255, 255);
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(10);
    doc.text(day.charAt(0).toUpperCase() + day.slice(1), x + width/2, y + headerHeight/2 + 3, { align: 'center' });
    
    // Message "Pas d'activit√©"
    doc.setFillColor(250, 250, 250);
    doc.rect(x, y + headerHeight, width, 30, 'F');
    doc.setTextColor(150, 150, 150);
    doc.setFont('helvetica', 'italic');
    doc.setFontSize(8);
    doc.text('Pas d\'activit√©', x + width/2, y + headerHeight + 15, { align: 'center' });
    
    // Bordures
    doc.setDrawColor(200, 200, 200);
    doc.setLineWidth(0.5);
    doc.rect(x, y, width, headerHeight + 30);
}

function drawPersonSummaryBottom(doc, personSchedule, startY, pageWidth) {
    const summary = calculatePersonSummary(personSchedule);
    
    if (Object.keys(summary.activities).length === 0) return;
    
    // Ligne de s√©paration
    doc.setDrawColor(200, 200, 200);
    doc.setLineWidth(0.5);
    doc.line(20, startY - 10, pageWidth - 20, startY - 10);
    
    // Titre du r√©sum√©
    doc.setFontSize(10);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(0, 0, 0);
    doc.text('R√©sum√© hebdomadaire :', 30, startY); // Ajout d'espace avant les deux-points
    
    // Total d'heures
    doc.setTextColor(102, 126, 234);
    doc.text(`Total : ${formatDuration(summary.totalMinutes)}`, 160, startY); // Ajout d'espace avant les deux-points
    
    // D√©tail par activit√© sur une ligne
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(8);
    
    let currentX = 260;
    const maxX = pageWidth - 30;
    const sortedActivities = Object.entries(summary.activities).sort((a, b) => b[1] - a[1]);
    
    sortedActivities.forEach(([activity, minutes]) => {
        const text = `${activity} : ${formatDuration(minutes)}`; // Ajout d'espaces autour des deux-points
        const textWidth = doc.getTextWidth(text) + 20; // Plus d'espace entre les √©l√©ments
        
        // V√©rifier si on d√©passe la largeur
        if (currentX + textWidth > maxX) {
            startY += 12;
            currentX = 260;
        }
        
        // Petit indicateur de couleur
        const activityColor = getActivityColorRGB(activity);
        if (activityColor) {
            doc.setFillColor(activityColor.r, activityColor.g, activityColor.b);
            doc.rect(currentX - 8, startY - 4, 5, 5, 'F');
        }
        
        doc.setTextColor(0, 0, 0);
        doc.text(text, currentX, startY);
        currentX += textWidth;
    });
}

function getPersonSchedule(col) {
    const schedule = {};
    
    days.forEach(day => {
        schedule[day] = {};
        timeSlots.forEach(time => {
            const activity = planningData[day][time][col];
            if (activity && activity.trim() !== '') {
                schedule[day][time] = activity;
            }
        });
    });
    
    return schedule;
}

function hasAnyActivity(personSchedule) {
    return days.some(day => 
        Object.keys(personSchedule[day]).length > 0
    );
}

function compressPersonTimeSlots(day, col) {
    const compressed = [];
    let currentBlock = null;
    
    timeSlots.forEach((time, index) => {
        const activity = planningData[day][time][col];
        
        if (activity && activity.trim() !== '') {
            if (currentBlock && currentBlock.activity === activity) {
                // Continuer le bloc actuel
                currentBlock.endTime = time;
                currentBlock.duration += 5;
            } else {
                // Commencer un nouveau bloc
                if (currentBlock) {
                    compressed.push(currentBlock);
                }
                currentBlock = {
                    startTime: time,
                    endTime: time,
                    activity: activity,
                    duration: 5
                };
            }
        } else {
            // Fin du bloc actuel si existant
            if (currentBlock) {
                compressed.push(currentBlock);
                currentBlock = null;
            }
        }
    });
    
    // Ajouter le dernier bloc si existant
    if (currentBlock) {
        compressed.push(currentBlock);
    }
    
    return compressed;
}

function calculatePersonSummary(personSchedule) {
    const summary = {
        totalMinutes: 0,
        activities: {}
    };
    
    days.forEach(day => {
        Object.entries(personSchedule[day]).forEach(([time, activity]) => {
            if (activity) {
                summary.totalMinutes += 5;
                if (!summary.activities[activity]) {
                    summary.activities[activity] = 0;
                }
                summary.activities[activity] += 5;
            }
        });
    });
    
    return summary;
}

function formatDuration(minutes) {
    if (minutes < 60) {
        return `${minutes} min`;
    }
    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    if (mins === 0) {
        return `${hours} h`; // Ajout d'espace avant 'h'
    }
    return `${hours} h ${mins.toString().padStart(2, '0')}`; // Ajout d'espaces autour de 'h'
}
</script>
</body>
</html>
